// Generated by CoffeeScript 1.4.0
(function() {
  var Annotation, ArgumentParser, DEBUG, PARSER_CFG, afunc, annotations, argparse, assert, call, d, formal_parameter_list, getargspec, getfullargspec, is_annotation, iterable, main, p4, parser, parser_from, parser_from1, path, pconf, util, _, _extract_kwargs, _match_cmd, _parser_registry,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (!(module.parent != null)) {
    DEBUG = function() {
      var arg;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      arg.unshift('==> ');
      return console.log.apply(console, arg);
    };
  } else {
    DEBUG = function() {};
  }

  util = require('util');

  assert = require('assert');

  path = require('path');

  _ = require('underscore');

  _.str = require('underscore.string');

  argparse = require('argcoffee');

  formal_parameter_list = function(fn) {
    var FN_ARG, FN_ARGS, FN_ARG_SPLIT, STRIP_COMMENTS, a, arg, arg_decl, args, cmts, doc, fn_text, name, r;
    FN_ARGS = /^function\s*([^\(]*)\(\s*([^\)]*)\)/m;
    FN_ARG_SPLIT = /,/;
    FN_ARG = /^\s*(\S+?)\s*$/;
    STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    args = [];
    name = null;
    doc = null;
    fn_text = fn.toString().replace(STRIP_COMMENTS, '');
    cmts = fn.toString().match(STRIP_COMMENTS);
    if ((cmts != null) && cmts.length > 0) {
      doc = cmts[0];
    }
    arg_decl = fn_text.match(FN_ARGS);
    name = arg_decl[1];
    arg_decl = arg_decl[2];
    r = arg_decl.split(FN_ARG_SPLIT);
    for (a in r) {
      arg = r[a];
      arg.replace(FN_ARG, function(all, name) {
        return args.push(name);
      });
    }
    if ((name != null) && name === '') {
      name = null;
    }
    if ((doc != null) && doc.length === 0) {
      doc = null;
    }
    return [args, name, doc];
  };

  getfullargspec = (function() {

    function getfullargspec(f) {
      var first, last, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      _ref = formal_parameter_list(f), this.args = _ref[0], this.name = _ref[1], this.doc = _ref[2];
      this.varargs = null;
      this.varkw = null;
      _ref1 = this.args, first = 2 <= _ref1.length ? __slice.call(_ref1, 0, _i = _ref1.length - 1) : (_i = 0, []), last = _ref1[_i++];
      if (last === 'kwarg' || last === 'kwargs' || last === '__kw' || last === 'varkw') {
        _ref2 = [first, last], this.args = _ref2[0], this.varkw = _ref2[1];
      }
      _ref3 = this.args, first = 2 <= _ref3.length ? __slice.call(_ref3, 0, _j = _ref3.length - 1) : (_j = 0, []), last = _ref3[_j++];
      if (last === 'vargs' || last === '_arg') {
        _ref4 = [first, last], this.args = _ref4[0], this.varargs = _ref4[1];
      }
      this.defaults = (_ref5 = f.defaults) != null ? _ref5 : [];
      this.annotations = (_ref6 = f.__annotations__) != null ? _ref6 : {};
    }

    return getfullargspec;

  })();

  getargspec = function(callableobj) {
    var argspec;
    if (_.isFunction(callableobj)) {
      argspec = new getfullargspec(callableobj);
      if (callableobj.name != null) {
        argspec.name = callableobj.name;
      }
    } else {
      throw new TypeError('Could not determine the signature of' + callableobj);
    }
    return argspec;
  };

  annotations = function(ann) {
    var annotate;
    annotate = function(f) {
      var argname, args, fas, _ref;
      fas = getargspec(f);
      args = fas.args;
      if (fas.varargs != null) {
        args.push(fas.varargs);
      }
      if (fas.varkw != null) {
        args.push(fas.varkw);
      }
      for (argname in ann) {
        if (_ref = !argname, __indexOf.call(args, _ref) >= 0) {
          thrown(new Error('Annotating non-existing argument' + argname));
        }
      }
      f.__annotations__ = ann;
      return f;
    };
    return annotate;
  };

  exports.annotations = annotations;

  is_annotation = function(obj) {
    return (obj.help != null) && (obj.kind != null) && (obj.abbrev != null) && (obj.type != null) && (obj.choices != null) && (obj.metaver != null);
  };

  Annotation = (function() {

    function Annotation(help, kind, abbrev, type, choices, metavar) {
      var _ref;
      this.help = help != null ? help : null;
      this.kind = kind != null ? kind : 'positional';
      this.abbrev = abbrev != null ? abbrev : null;
      this.type = type != null ? type : null;
      this.choices = choices != null ? choices : null;
      this.metavar = metavar != null ? metavar : null;
      assert((_ref = this.kind) === 'positional' || _ref === 'option' || _ref === 'flag', 'kind should be positional, option, or flag');
      if (this.kind === 'positional') {
        assert(this.abbrev === null, 'abbrev for positional should be null');
      }
    }

    Annotation.from_ = function(obj) {
      if (is_annotation(obj)) {
        return obj;
      } else if (_.isArray(obj)) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Annotation, obj, function(){});
      }
      return new Annotation(obj);
    };

    return Annotation;

  })();

  PARSER_CFG = 'prog, usage, epilog, parents, formatter_class, fromfile_prefix_chars, ' + 'add_help, debug, description, prefix_chars, argument_default, conflict_handler, ' + 'version';

  PARSER_CFG = PARSER_CFG.split(', ');

  pconf = function(obj) {
    var argspec, cfg, doc, key, name, _ref, _ref1;
    doc = name = null;
    try {
      argspec = getargspec(obj);
      doc = (_ref = argspec.doc) != null ? _ref : null;
      name = (_ref1 = argspec.name) != null ? _ref1 : null;
    } catch (TypeError) {
      "";

    }
    if (!(name != null) || name === '') {
      name = null;
    }
    cfg = {
      prog: name,
      description: doc
    };
    for (key in obj) {
      if (__indexOf.call(PARSER_CFG, key) >= 0) {
        cfg[key] = obj[key];
      }
    }
    return cfg;
  };

  _parser_registry = {};

  _parser_registry.get = function(obj) {
    return null;
  };

  _parser_registry.set = function(obj, p) {
    return _parser_registry[obj] = p;
  };

  parser_from = function(obj, confparams) {
    var conf, parser, _ref, _ref1;
    if (confparams == null) {
      confparams = {};
    }
    if (_parser_registry.get(obj) != null) {
      return _parser_registry.get(obj);
    }
    conf = _.extend({}, pconf(obj), confparams);
    parser = new ArgumentParser(conf);
    _parser_registry.set(obj, parser);
    parser.obj = obj;
    parser.case_sensitive = (_ref = (_ref1 = confparams['case_sensitive']) != null ? _ref1 : obj['case_sensitive']) != null ? _ref : true;
    if (obj['commands'] != null) {
      parser.addsubcommands(obj.commands, obj, 'subcommands');
    } else {
      parser.populate_from(obj);
    }
    return parser;
  };

  exports.parser_from = parser_from;

  _extract_kwargs = function(args) {
    var arg, arglist, kwargs, m, name, _i, _len;
    arglist = [];
    kwargs = {};
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      m = arg.match(/([a-zA-Z_]\w*)=/);
      if (m != null) {
        name = m[1];
        kwargs[name] = arg.slice(name.length + 1);
      } else {
        arglist.push(arg);
      }
    }
    return [arglist, kwargs];
  };

  _match_cmd = function(abbrev, commands, case_sensitive) {
    var c, matches, n, name, perfect_matches;
    if (case_sensitive == null) {
      case_sensitive = true;
    }
    commands = _.keys(commands);
    if (!case_sensitive) {
      abbrev = abbrev.toUpperCase();
      commands = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = commands.length; _i < _len; _i++) {
          c = commands[_i];
          _results.push(c.toUpperCase());
        }
        return _results;
      })();
    }
    perfect_matches = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = commands.length; _i < _len; _i++) {
        name = commands[_i];
        if (name === abbrev) {
          _results.push(name);
        }
      }
      return _results;
    })();
    if (perfect_matches.length === 1) {
      return perfect_matches[0];
    }
    matches = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = commands.length; _i < _len; _i++) {
        name = commands[_i];
        if (_.str.startsWith(name, abbrev)) {
          _results.push(name);
        }
      }
      return _results;
    })();
    n = matches.length;
    if (n === 1) {
      return matches[0];
    } else if (n > 1) {
      throw Error("Ambiguous command " + abbrev + " matching " + matches);
    }
  };

  ArgumentParser = (function(_super) {
    var case_sensitive;

    __extends(ArgumentParser, _super);

    function ArgumentParser(options) {
      ArgumentParser.__super__.constructor.call(this, options);
    }

    case_sensitive = true;

    ArgumentParser.prototype.alias = function(arg) {
      return arg;
    };

    ArgumentParser.prototype.consume = function(args) {
      var a, alist, arg, arglist, cmd, collision, extraopts, kwargs, ns, subp, varargs, _ref, _ref1, _ref2, _ref3, _ref4;
      arglist = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          a = args[_i];
          _results.push(this.alias(a));
        }
        return _results;
      }).call(this);
      cmd = null;
      if (this.subparsers != null) {
        _ref = this._extract_subparser_cmd(arglist), subp = _ref[0], cmd = _ref[1], arglist = _ref[2];
        DEBUG(cmd, arglist);
        if (!(subp != null) && (cmd != null)) {
          return [cmd, this.missing(cmd)];
        } else if (subp != null) {
          return subp.consume(arglist);
        }
      }
      if ((this.argspec != null) && !_.isEmpty(this.argspec.varkw)) {
        _ref1 = _extract_kwargs(arglist), arglist = _ref1[0], kwargs = _ref1[1];
      } else {
        kwargs = {};
      }
      if ((this.argspec != null) && (this.argspec.varargs != null)) {
        _ref2 = this.parseKnownArgs(arglist), ns = _ref2[0], extraopts = _ref2[1];
      } else {
        _ref3 = [this.parse_args(arglist), []], ns = _ref3[0], extraopts = _ref3[1];
      }
      DEBUG('ns', ns);
      DEBUG('extrapopts', extraopts);
      args = (function() {
        var _i, _len, _ref4, _results;
        _ref4 = this.argspec.args;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          a = _ref4[_i];
          _results.push(ns[a]);
        }
        return _results;
      }).call(this);
      varargs = (_ref4 = ns[this.argspec.varargs]) != null ? _ref4 : [];
      collision = (function() {
        var _i, _len, _ref5, _results;
        _ref5 = this.argspec.args;
        _results = [];
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          arg = _ref5[_i];
          if (arg in kwargs) {
            _results.push(arg);
          }
        }
        return _results;
      }).call(this);
      if (collision.length > 0) {
        this.error('colliding keyword arguments: ' + collision);
      }
      alist = [].concat(args, [varargs], extraopts);
      DEBUG('alist', alist);
      DEBUG('kwargs', kwargs);
      return [cmd, this.func.apply(this, __slice.call(alist).concat([kwargs]))];
    };

    ArgumentParser.prototype._extract_subparser_cmd = function(arglist) {
      var arg, cmd, i, name_parser_map, optprefix, _i, _len;
      optprefix = this.prefix_chars[0];
      name_parser_map = this.subparsers._name_parser_map;
      for (i = _i = 0, _len = arglist.length; _i < _len; i = ++_i) {
        arg = arglist[i];
        if (!(arg[0] !== optprefix)) {
          continue;
        }
        cmd = _match_cmd(arg, name_parser_map, this.case_sensitive);
        arglist = arglist.splice(i + 1);
        return [name_parser_map[cmd], cmd || arg, arglist];
      }
      return [null, null, arglist];
    };

    ArgumentParser.prototype.addsubcommands = function(commands, obj, title, cmdprefix) {
      var add_help, cmd, func, options, prefixlen, subparser, _i, _len, _ref, _ref1, _results;
      if (title == null) {
        title = null;
      }
      if (cmdprefix == null) {
        cmdprefix = '';
      }
      options = {
        title: title
      };
      options['parser_class'] = ArgumentParser;
      if (!(this.subparsers != null)) {
        this.subparsers = this.addSubparsers(options);
      } else if (title != null) {
        this.add_argument_group(options);
      }
      prefixlen = ((_ref = obj.cmdprefix) != null ? _ref : '').length;
      add_help = (_ref1 = obj.add_help) != null ? _ref1 : true;
      _results = [];
      for (_i = 0, _len = commands.length; _i < _len; _i++) {
        cmd = commands[_i];
        func = obj[cmd.slice(prefixlen)];
        options = {
          add_help: add_help,
          help: 'subparser help'
        };
        subparser = this.subparsers.addParser(cmd, options);
        _results.push(subparser.populate_from(func));
      }
      return _results;
    };

    ArgumentParser.prototype._set_func_argspec = function(obj) {
      this.func = obj;
      this.argspec = getargspec(obj);
      return _parser_registry.set(obj, this);
    };

    ArgumentParser.prototype.populate_from = function(func) {
      var a, alldefaults, ann, defaultValue, defaults, dflt, f, i, metavar, n_args, n_defaults, name, nargs, prefix, shortlong, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      this._set_func_argspec(func);
      f = this.argspec;
      defaults = (_ref = f.defaults) != null ? _ref : [];
      n_args = f.args.length;
      n_defaults = defaults.length;
      alldefaults = ((function() {
        var _i, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref1 = n_args - n_defaults; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(null);
        }
        return _results;
      })()).concat(defaults);
      DEBUG(f.args, alldefaults);
      prefix = this.prefix = ((_ref1 = func.prefix_chars) != null ? _ref1 : '-')[0];
      _ref2 = _.zip(f.args, alldefaults);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], name = _ref3[0], defaultValue = _ref3[1];
        ann = (_ref4 = f.annotations[name]) != null ? _ref4 : [];
        a = Annotation.from_(ann);
        metavar = a.metavar;
        if (!(defaultValue != null)) {
          dflt = null;
        } else {
          dflt = defaultValue;
          if (!(a.help != null)) {
            a.help = "[" + dflt + "]";
          }
        }
        if ((_ref5 = a.kind) === 'option' || _ref5 === 'flag') {
          if (a.abbrev != null) {
            shortlong = [prefix + a.abbrev, prefix + prefix + name.replace('_', '-')];
          } else {
            shortlong = [prefix + name.replace('_', '-')];
          }
        } else if (!(dflt != null)) {
          this.addArgument([name], {
            help: a.help,
            type: a.type,
            choices: a.choices,
            metavar: metavar
          });
        } else {
          nargs = _.str.endsWith(name, 's') ? '*' : '?';
          this.addArgument([name], {
            nargs: nargs,
            help: a.help,
            defaultValue: dflt,
            type: a.type,
            choices: a.choices,
            metavar: metavar
          });
        }
        if (a.kind === 'option') {
          if (defaultValue != null) {
            metavar = metavar != null ? metavar : "" + defaultValue;
          }
          this.addArgument(shortlong, {
            help: a.help,
            defaultValue: dflt,
            type: a.type,
            choices: a.choices,
            metavar: metavar
          });
        } else if (a.kind === 'flag') {
          if ((defaultValue != null) && defaultValue !== false) {
            throw new TypeError("Flag " + name + " wants default false, got " + defaultValue);
          }
          this.addArgument(shortlong, {
            action: 'storeTrue',
            help: a.help
          });
        }
      }
      if (f.varargs != null) {
        a = Annotation.from_((_ref6 = f.annotations[f.varargs]) != null ? _ref6 : []);
        this.addArgument([f.varargs], {
          nargs: '*',
          help: a.help,
          defaultValue: [],
          type: a.type,
          metavar: a.metavar
        });
      }
      if (f.varkw != null) {
        a = Annotation.from_((_ref7 = f.annotations[f.varkw]) != null ? _ref7 : []);
        return this.addArgument([f.varkw], {
          nargs: '*',
          help: a.help,
          defaultValue: {},
          type: a.type,
          metavar: a.metavar
        });
      }
    };

    ArgumentParser.prototype.missing = function(name) {
      var miss, _ref,
        _this = this;
      miss = (_ref = this.obj['__missing__']) != null ? _ref : function(name) {
        return _this.error("No command " + name);
      };
      return miss(name);
    };

    ArgumentParser.prototype.print_actions = function() {
      var a;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this._actions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          a = _ref[_i];
          _results.push(a.repr());
        }
        return _results;
      }).call(this)).join('\n');
    };

    return ArgumentParser;

  })(argparse.ArgumentParser);

  iterable = function(obj) {
    return (obj.__iter__ != null) && !_.isString(obj);
  };

  call = function(obj, arglist, options) {
    var cmd, result, _ref;
    if (arglist == null) {
      arglist = process.argv.slice(2);
    }
    if (options == null) {
      options = {};
    }
    _ref = parser_from(obj, options).consume(arglist), cmd = _ref[0], result = _ref[1];
    return result;
  };

  exports.call = call;

  if (!(module.parent != null)) {
    console.log(require.module === module);
    main = function(aflag, anopt, aposit, vargs, kwargs) {
      /* Do something with the database
       vargs... is not usable; coffee just uses 'arguments'
      */
      console.log('main args:', aflag, anopt, aposit, vargs, kwargs);
      return 'Done';
    };
    d = {
      aflag: ["a flag", 'flag'],
      anopt: ["an optional", 'option'],
      aposit: ["a positional", 'positional'],
      vargs: ["multi element ", 'positional'],
      kwargs: ["keyword args", 'positional']
    };
    main = annotations(d)(main);
    main.defaults = ['posdefault'];
    main.name = 'MAIN';
    main.description = 'documentation for main';
    parser = parser_from(main, {
      prog: 'Main',
      description: 'plac version of argparse sum example',
      debug: true
    });
    console.log(parser.formatHelp());
    console.log(parser.consume([]));
    console.log(parser.consume(['-aflag', '-anopt', '42', 'posarg', 'var1', 'var2', 'one=1', 'two=foo']));
    console.log('====================================');
    parser_from1 = function(f, kw) {
      f.__annotations__ = kw;
      return parser_from(f, {
        debug: true
      });
    };
    p4 = parser_from1((function(delete_, delete_all, color) {
      return None;
    }), {
      delete_: ['delete a file', 'option', 'd'],
      delete_all: ['delete all files', 'flag', 'a'],
      color: ['color', 'option', 'c']
    });
    console.log(p4.formatHelp());
    console.log("========================\ntest subparsers");
    afunc = function(bar) {
      /* a command
      */
      return ['a bar:', bar];
    };
    main = function() {
      return "DONE";
    };
    main.a = afunc;
    main.b = function(baz) {
      /* b command takes one arg
      */
      return ['b baz:', baz];
    };
    d = {};
    main = annotations(d)(main);
    main.commands = ['a', 'b'];
    main.description = 'documentation for main';
    parser = parser_from(main, {
      debug: true
    });
    console.log(parser.formatHelp());
    console.log('a bar', parser.consume(['a', 42]));
    console.log('');
    try {
      console.log('b', parser.consume(['b', 'BAZ']));
    } catch (error) {
      console.log(error);
    }
    try {
      parser.consume(['-h']);
    } catch (error) {

    }
    try {
      parser.consume(['a', '-h']);
    } catch (error) {

    }
    console.log('done');
  }

  /*
  in py
  def foo3(x,y=3,a=None,*z,**w):
      print x,y,z,w
      return 'done'
     ....: 
  
  vars(plac.getargspec(foo3)) 
  {'annotations': {},
   'args': ['x', 'y', 'a'],
   'defaults': (3, None),
   'varargs': 'z',
   'varkw': 'w'}
  
  in js, there are only args
  coffee adds defaults (of sorts)
  and something like *z, array turned into string of args 
  but those aren't directly visible in underlying js
  
  square = function(x) {
    return x * x;
  };
  square.toString()
  square.length   # of named arguments
  
  function square(x) {...} will have square.name = 'square'
  bar = function foo(x)
  */


}).call(this);
