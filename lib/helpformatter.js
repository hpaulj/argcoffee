// Generated by CoffeeScript 1.6.1
var $$, ArgumentDefaultsHelpFormatter, DEBUG, HelpFormatter, HelpFormatter_js, RawDescriptionHelpFormatter, RawTextHelpFormatter, adir, ag, ap, args, assert, fmtwindent, formatter, group, group2, parser, parser_a, parser_b, path, pformat, pnformat, setup, subparsers, util, x, _, _i, _len, _ref, _textwrap,
  __slice = [].slice,
  _this = this,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (module.parent == null) {
  DEBUG = function() {
    var arg;
    arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    arg.unshift('==> ');
    return console.log.apply(console, arg);
  };
} else {
  DEBUG = function() {};
}

util = require('util');

assert = require('assert');

path = require('path');

_ = require('underscore');

_.str = require('underscore.string');

adir = './';

$$ = require('./const');

fmtwindent = function(fmt, tup) {
  var i, indent, indentstr, spc, text, trailing, width;
  indent = tup[0], text = tup[1], width = tup[2], spc = tup[3];
  spc = spc != null ? spc : ' ';
  text = text != null ? text : '';
  indentstr = ((function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; 0 <= indent ? _i < indent : _i > indent; i = 0 <= indent ? ++_i : --_i) {
      _results.push(spc);
    }
    return _results;
  })()).join('');
  text = indentstr + text;
  if (width != null) {
    text = _.str.pad(text, width + indent, ' ', 'right');
  }
  trailing = _.str.strRightBack(fmt, 's');
  if (trailing !== fmt) {
    text = text + trailing;
  } else if (_.str.endsWith(fmt, '\n')) {
    text = text + '\n';
  }
  return text;
};

_textwrap = {
  wrap: function(text, width, initial_indent, subsequent_indent) {
    if (initial_indent == null) {
      initial_indent = 0;
    }
    if (subsequent_indent == null) {
      subsequent_indent = 0;
    }
    return [text];
  },
  fill: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return _textwrap.wrap.apply(_textwrap, args).join('\n');
  }
};

pformat = function(fmt, params) {
  var p, _i, _len;
  for (_i = 0, _len = params.length; _i < _len; _i++) {
    p = params[_i];
    fmt = fmt.replace(/%s/, p);
  }
  return fmt;
};

pnformat = function(fmt, params) {
  var k;
  for (k in params) {
    fmt = fmt.replace("%(" + k + ")s", params[k]);
  }
  return fmt;
};

exports.HelpFormatter = HelpFormatter = (function() {
  /*Formatter for generating usage messages and argument help strings.
  
  Only the name of this class is considered a public API. All the methods
  provided by the class are considered an implementation detail.
  */

  var _Section,
    _this = this;

  function HelpFormatter(options) {
    var indent_increment, max_help_position, prog, width, _ref, _ref1, _ref2, _ref3, _ref4,
      _this = this;
    if (options == null) {
      options = {};
    }
    this._format_action_invocation = function(action) {
      return HelpFormatter.prototype._format_action_invocation.apply(_this, arguments);
    };
    this._format_action = function(action) {
      return HelpFormatter.prototype._format_action.apply(_this, arguments);
    };
    this._format_text = function(text) {
      return HelpFormatter.prototype._format_text.apply(_this, arguments);
    };
    this._format_actions_usage = function(actions, groups) {
      return HelpFormatter.prototype._format_actions_usage.apply(_this, arguments);
    };
    this._format_usage = function(usage, actions, groups, prefix) {
      return HelpFormatter.prototype._format_usage.apply(_this, arguments);
    };
    prog = options.prog;
    indent_increment = (_ref = (_ref1 = options.indent_increment) != null ? _ref1 : options.indentIncrement) != null ? _ref : 2;
    max_help_position = (_ref2 = (_ref3 = options.max_help_position) != null ? _ref3 : options.maxHelpPosition) != null ? _ref2 : 24;
    width = (_ref4 = options.width) != null ? _ref4 : null;
    if (width == null) {
      width = 80 - 2;
    }
    this._prog = prog;
    this._indent_increment = indent_increment;
    this._max_help_position = max_help_position;
    this._width = width;
    this._current_indent = 0;
    this._level = 0;
    this._action_max_length = 0;
    this._root_section = new this._Section(this, null);
    this._current_section = this._root_section;
    this._whitespace_matcher = /\s+/g;
    this._long_break_matcher = /\n\n\n+/g;
    this._prog_matcher = /%\(prog\)s/;
  }

  HelpFormatter.prototype._indent = function() {
    this._current_indent += this._indent_increment;
    return this._level += 1;
  };

  HelpFormatter.prototype._dedent = function() {
    this._current_indent -= this._indent_increment;
    assert(this._current_indent >= 0, 'Indent decreased below 0.');
    return this._level -= 1;
  };

  HelpFormatter.prototype._Section = _Section = (function() {

    function _Section(formatter, parent, heading) {
      var _this = this;
      if (heading == null) {
        heading = null;
      }
      this.format_help = function() {
        return _Section.prototype.format_help.apply(_this, arguments);
      };
      this.formatter = formatter;
      this.parent = parent;
      this.heading = heading;
      this.items = [];
    }

    _Section.prototype.format_help = function() {
      var args, current_indent, func, heading, item_help, join;
      if (this.parent != null) {
        this.formatter._indent();
      }
      join = this.formatter._join_parts;
      item_help = join((function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = this.items;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], func = _ref1[0], args = _ref1[1];
          _results.push(func.apply(null, args));
        }
        return _results;
      }).call(this));
      if (this.parent != null) {
        this.formatter._dedent();
      }
      if (item_help.length === 0) {
        return '';
      }
      if (this.heading !== $$.SUPPRESS && this.heading !== null) {
        current_indent = this.formatter._current_indent;
        heading = fmtwindent('%*s%s:\n', [current_indent, this.heading]);
      } else {
        heading = '';
      }
      return join(['\n', heading, item_help, '\n']);
    };

    return _Section;

  })();

  HelpFormatter.prototype._add_item = function(func, args) {
    return this._current_section.items.push([func, args]);
  };

  HelpFormatter.prototype.start_section = function(heading) {
    var section;
    this._indent();
    section = new this._Section(this, this._current_section, heading);
    this._add_item(section.format_help, []);
    return this._current_section = section;
  };

  HelpFormatter.prototype.startSection = function(heading) {
    return this.start_section(heading);
  };

  HelpFormatter.prototype.end_section = function() {
    this._current_section = this._current_section.parent;
    return this._dedent();
  };

  HelpFormatter.prototype.endSection = function() {
    return this.end_section();
  };

  HelpFormatter.prototype.add_text = function(text) {
    if (text !== $$.SUPPRESS && (text != null)) {
      return this._add_item(this._format_text, [text]);
    }
  };

  HelpFormatter.prototype.addText = function(text) {
    return this.add_text(text);
  };

  HelpFormatter.prototype.add_usage = function(usage, actions, groups, prefix) {
    var args;
    if (prefix == null) {
      prefix = null;
    }
    if (usage !== $$.SUPPRESS) {
      args = [usage, actions, groups, prefix];
      return this._add_item(this._format_usage, args);
    }
  };

  HelpFormatter.prototype.addUsage = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.add_usage.apply(this, args);
  };

  HelpFormatter.prototype.add_argument = function(action) {
    var action_length, invocation_length, invocations, s, subaction, _i, _len, _ref;
    if (action.help !== $$.SUPPRESS) {
      invocations = [this._format_action_invocation(action)];
      if (action._get_subactions != null) {
        _ref = action._get_subactions();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subaction = _ref[_i];
          this._indent();
          invocations.push(this._format_action_invocation(subaction));
          this._dedent();
        }
      }
      invocation_length = Math.max.apply(Math, (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = invocations.length; _j < _len1; _j++) {
          s = invocations[_j];
          _results.push(s.length);
        }
        return _results;
      })());
      action_length = invocation_length + this._current_indent;
      this._action_max_length = Math.max(this._action_max_length, action_length);
      return this._add_item(this._format_action, [action]);
    }
  };

  HelpFormatter.prototype.addArgument = function(action) {
    return this.add_argument(action);
  };

  HelpFormatter.prototype.add_arguments = function(actions) {
    var action, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = actions.length; _i < _len; _i++) {
      action = actions[_i];
      _results.push(this.add_argument(action));
    }
    return _results;
  };

  HelpFormatter.prototype.addArguments = function(actions) {
    return this.add_arguments(actions);
  };

  HelpFormatter.prototype.format_help = function() {
    var help;
    help = this._root_section.format_help();
    if ((help != null) && help.length > 0) {
      help = help.replace(this._long_break_matcher, '\n\n');
      help = _.str.strip(help, '\n') + '\n';
    }
    return help;
  };

  HelpFormatter.prototype.formatHelp = function() {
    return this.format_help();
  };

  HelpFormatter.prototype._join_parts = function(part_strings) {
    var part;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = part_strings.length; _i < _len; _i++) {
        part = part_strings[_i];
        if (part && part !== $$.SUPPRESS) {
          _results.push(part);
        }
      }
      return _results;
    })()).join('');
  };

  HelpFormatter.prototype._format_usage = function(usage, actions, groups, prefix) {
    var action, action_usage, format, get_lines, indent, lines, opt_parts, opt_usage, optionals, part_regexp, parts, pos_parts, pos_usage, positionals, prog, s, text_width, _i, _len, _ref, _ref1;
    if (prefix === null) {
      prefix = 'usage: ';
    }
    if (usage != null) {
      usage = usage.replace(this._prog_matcher, this._prog);
    } else if ((usage == null) && actions.length === 0) {
      usage = this._prog;
    } else if (usage == null) {
      prog = this._prog;
      optionals = [];
      positionals = [];
      for (_i = 0, _len = actions.length; _i < _len; _i++) {
        action = actions[_i];
        if (action.isOptional()) {
          optionals.push(action);
        } else {
          positionals.push(action);
        }
      }
      format = this._format_actions_usage;
      action_usage = format([].concat(optionals, positionals), groups);
      usage = ((function() {
        var _j, _len1, _ref, _results;
        _ref = [prog, action_usage];
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          s = _ref[_j];
          if (s) {
            _results.push(s);
          }
        }
        return _results;
      })()).join(' ');
      text_width = this._width - this._current_indent;
      if (prefix.length + usage.length > text_width) {
        part_regexp = /\(.*?\)+|\[.*?\]+|\S+/g;
        opt_usage = format(optionals, groups);
        pos_usage = format(positionals, groups);
        opt_parts = (_ref = opt_usage.match(part_regexp)) != null ? _ref : [];
        pos_parts = (_ref1 = pos_usage.match(part_regexp)) != null ? _ref1 : [];
        get_lines = function(parts, indent, prefix) {
          var line, line_len, lines, part, _j, _len1;
          if (prefix == null) {
            prefix = null;
          }
          lines = [];
          line = [];
          if (prefix != null) {
            line_len = prefix.length - 1;
          } else {
            line_len = indent.length - 1;
          }
          for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
            part = parts[_j];
            if (line_len + 1 + part.length > text_width) {
              lines.push(indent + line.join(' '));
              line = [];
              line_len = indent.length - 1;
            }
            line.push(part);
            line_len += part.length + 1;
          }
          if (line.length > 0) {
            lines.push(indent + line.join(' '));
          }
          if (prefix != null) {
            lines[0] = lines[0].slice(indent.length);
          }
          return lines;
        };
        if (prefix.length + prog.length <= 0.75 * text_width) {
          indent = fmtwindent('', [prefix.length + prog.length + 1]);
          if (opt_parts.length > 0) {
            lines = [prog].concat(opt_parts);
            lines = get_lines(lines, indent, prefix);
            lines = lines.concat(get_lines(pos_parts, indent));
          } else if (pos_parts.length > 0) {
            lines = [prog].concat(pos_parts);
            lines = get_lines(lines, indent, prefix);
          } else {
            lines = [prog];
          }
        } else {
          indent = fmtwindent('', [prefix.length]);
          opt_parts.concat(pos_parts);
          parts = opt_parts;
          lines = get_lines(parts, indent);
          if (lines.length > 1) {
            lines = [];
            lines.concat(get_lines(opt_parts, indent));
            lines.concat(get_lines(pos_parts, indent));
          }
          lines.unshift(prog);
        }
        usage = lines.join('\n');
      }
    }
    return prefix + usage + "\n\n";
  };

  HelpFormatter.prototype._format_actions_usage = function(actions, groups) {
    var action, args_string, defaultValue, end, group, group_actions, i, inserts, item, k, option_string, pairs, part, parts, start, text, v, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1, _ref2, _ref3;
    group_actions = [];
    inserts = {};
    for (_i = 0, _len = groups.length; _i < _len; _i++) {
      group = groups[_i];
      start = actions.indexOf(group._group_actions[0]);
      end = start + group._group_actions.length;
      if (_.isEqual(actions.slice(start, end), group._group_actions)) {
        _ref = group._group_actions;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          action = _ref[_j];
          group_actions.push(action);
        }
        if (!group.required) {
          if (start in inserts) {
            inserts[start] += ' [';
          } else {
            inserts[start] = '[';
          }
          inserts[end] = ']';
        } else {
          if (start in inserts) {
            inserts[start] += ' (';
          } else {
            inserts[start] = '(';
          }
          inserts[end] = ')';
        }
        for (i = _k = _ref1 = start + 1; _ref1 <= end ? _k < end : _k > end; i = _ref1 <= end ? ++_k : --_k) {
          inserts[i] = '|';
        }
      }
    }
    parts = [];
    for (i = _l = 0, _len2 = actions.length; _l < _len2; i = ++_l) {
      action = actions[i];
      if (action.help === $$.SUPPRESS) {
        parts.push(null);
        if (inserts[i] === '|') {
          delete inserts[i];
        } else if (inserts[i + 1] === '|') {
          delete inserts[i + 1];
        }
      } else if (action.isPositional()) {
        part = this._format_args(action, action.dest);
        if (__indexOf.call(group_actions, action) >= 0) {
          if (part[0] === '[' && _.last(part) === ']') {
            part = part.slice(1, part.length - 1);
          }
        }
        parts.push(part);
      } else {
        option_string = action.option_strings[0];
        if (action.nargs === 0) {
          part = option_string;
        } else {
          defaultValue = action.dest.toUpperCase();
          args_string = this._format_args(action, defaultValue);
          part = "" + option_string + " " + args_string;
        }
        if (!action.required && __indexOf.call(group_actions, action) < 0) {
          part = "[" + part + "]";
        }
        parts.push(part);
      }
    }
    pairs = _.pairs(inserts);
    if (pairs.length > 0) {
      for (i = _m = _ref2 = pairs.length - 1; _ref2 <= 0 ? _m <= 0 : _m >= 0; i = _ref2 <= 0 ? ++_m : --_m) {
        _ref3 = pairs[i], k = _ref3[0], v = _ref3[1];
        if (v != null) {
          parts.splice(k, 0, v);
        }
      }
    }
    text = ((function() {
      var _len3, _n, _results;
      _results = [];
      for (_n = 0, _len3 = parts.length; _n < _len3; _n++) {
        item = parts[_n];
        if (item != null) {
          _results.push(item);
        }
      }
      return _results;
    })()).join(' ');
    text = text.replace(/([\[(]) /g, '$1');
    text = text.replace(/\ ([\])])/g, '$1');
    text = text.replace(/\[ *\]/g, '');
    text = text.replace(/\( *\)/g, '');
    text = text.replace(/\(([^|]*)\)/g, '$1');
    text = _.str.strip(text);
    return text;
  };

  HelpFormatter.prototype._format_text = function(text) {
    var indent, text_width;
    text = text.replace(this._prog_matcher, this._prog);
    text_width = this._width - this._current_indent;
    indent = fmtwindent('', [this._current_indent]);
    return this._fill_text(text, text_width, indent) + '\n\n';
  };

  HelpFormatter.prototype._format_action = function(action) {
    var action_header, action_width, help_lines, help_position, help_text, help_width, indent_first, line, parts, subaction, tup, _i, _j, _len, _len1, _ref, _ref1;
    help_position = Math.min(this._action_max_length + 2, this._max_help_position);
    help_width = this._width - help_position;
    action_width = help_position - this._current_indent - 2;
    action_header = this._format_action_invocation(action);
    if (action.help == null) {
      action_header = fmtwindent('%*s%s\n', [this._current_indent, action_header]);
    } else if (action_header.length <= action_width) {
      tup = [this._current_indent, action_header, action_width];
      action_header = fmtwindent('%*s%-*s  ', tup);
      indent_first = 0;
    } else {
      action_header = fmtwindent('%*s%s\n', [this._current_indent, action_header]);
      indent_first = help_position;
    }
    parts = [action_header];
    if (action.help != null) {
      help_text = this._expand_help(action);
      help_lines = this._split_lines(help_text, help_width);
      parts.push(fmtwindent('%*s%s\n', [indent_first, help_lines[0]]));
      _ref = help_lines.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        parts.push(fmtwindent('%*s%s\n', [help_position, line]));
      }
    } else if (!_.str.endsWith(action_header, '\n')) {
      parts.push('\n');
    }
    if (action._get_subactions != null) {
      _ref1 = action._get_subactions();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        subaction = _ref1[_j];
        this._indent();
        parts.push(this._format_action(subaction));
        this._dedent();
      }
    }
    return this._join_parts(parts);
  };

  HelpFormatter.prototype._format_action_invocation = function(action) {
    var args_string, defaultValue, metavar, option_string, parts, _i, _len, _ref;
    if (action.isPositional()) {
      metavar = this._metavar_formatter(action, action.dest)(1)[0];
      return metavar;
    } else {
      parts = [];
      if (action.nargs === 0) {
        parts = parts.concat(action.option_strings);
      } else {
        defaultValue = action.dest.toUpperCase();
        args_string = this._format_args(action, defaultValue);
        _ref = action.option_strings;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          option_string = _ref[_i];
          parts.push("" + option_string + " " + args_string);
        }
      }
      return parts.join(', ');
    }
  };

  HelpFormatter.prototype._metavar_formatter = function(action, default_metavar) {
    var choices, format, result;
    if (action.metavar != null) {
      result = action.metavar;
    } else if (action.choices != null) {
      if (_.isString(action.choices)) {
        choices = action.choices;
        choices = choices.split(/\W+/);
        if (choices.length === 1) {
          choices = choices[0].split('');
        }
      } else if (_.isArray(action.choices)) {
        choices = action.choices;
      } else if (_.isObject(action.choices)) {
        choices = _.keys(action.choices);
      } else {
        throw new Error('bad choices variable');
      }
      result = "{" + (choices.join(',')) + "}";
    } else {
      result = default_metavar;
    }
    format = function(tuple_size) {
      var i;
      return (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= tuple_size ? _i < tuple_size : _i > tuple_size; i = 0 <= tuple_size ? ++_i : --_i) {
          _results.push(result);
        }
        return _results;
      })();
    };
    format = function(tuple_size) {
      var i;
      if (_.isArray(result)) {
        return result;
      } else {
        return (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= tuple_size ? _i < tuple_size : _i > tuple_size; i = 0 <= tuple_size ? ++_i : --_i) {
            _results.push(result);
          }
          return _results;
        })();
      }
    };
    return format;
  };

  HelpFormatter.prototype._format_args = function(action, default_metavar) {
    var formats, get_metavar, i, result;
    get_metavar = this._metavar_formatter(action, default_metavar);
    if (action.nargs == null) {
      result = pformat('%s', get_metavar(1));
    } else if (action.nargs === $$.OPTIONAL) {
      result = pformat('[%s]', get_metavar(1));
    } else if (action.nargs === $$.ZERO_OR_MORE) {
      result = pformat('[%s [%s ...]]', get_metavar(2));
    } else if (action.nargs === $$.ONE_OR_MORE) {
      result = pformat('%s [%s ...]', get_metavar(2));
    } else if (action.nargs === $$.REMAINDER) {
      result = '...';
    } else if (action.nargs === $$.PARSER) {
      result = pformat('%s ...', get_metavar(1));
    } else {
      formats = ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = action.nargs; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push('%s');
        }
        return _results;
      })()).join(' ');
      result = pformat(formats, get_metavar(action.nargs));
    }
    return result;
  };

  HelpFormatter.prototype._expand_help = function(action) {
    var c, choices_str, name, params, _ref;
    params = _.clone(action);
    params.prog = this._prog;
    for (name in params) {
      if (params[name] === $$.SUPPRESS) {
        delete params[name];
      }
    }
    for (name in params) {
      if (((_ref = params[name]) != null ? _ref.__name__ : void 0) != null) {
        params[name] = params[name].__name__;
      }
    }
    if (params.choices != null) {
      choices_str = ((function() {
        var _i, _len, _ref1, _results;
        _ref1 = params.choices;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          _results.push('' + c);
        }
        return _results;
      })()).join(', ');
      params.choices = choices_str;
    }
    return pnformat(this._get_help_string(action), params);
  };

  HelpFormatter.prototype._indented_subactions = function(action) {};

  HelpFormatter.prototype._split_lines = function(text, width, indent) {
    var cnt, line, lines, wd, wds, _i, _len;
    if (width == null) {
      width = 80;
    }
    if (indent == null) {
      indent = 0;
    }
    text = text.replace(this._whitespace_matcher, ' ');
    text = _.str.strip(text);
    wds = text.split(' ');
    lines = [];
    line = [];
    cnt = 0;
    for (_i = 0, _len = wds.length; _i < _len; _i++) {
      wd = wds[_i];
      if ((cnt + wd.length + 1) < (width - indent)) {
        line.push(wd);
        cnt += wd.length + 1;
      } else {
        lines.push(line.join(' '));
        line = [wd];
        cnt = wd.length + 1;
      }
    }
    lines.push(line.join(' '));
    return lines;
  };

  HelpFormatter.prototype._fill_text = function(text, width, indent) {
    var line;
    if (indent == null) {
      indent = 0;
    }
    text = this._split_lines(text, width, indent);
    text = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = text.length; _i < _len; _i++) {
        line = text[_i];
        _results.push(indent + line);
      }
      return _results;
    })();
    text = text.join('\n');
    return text;
  };

  HelpFormatter.prototype._get_help_string = function(action) {
    return action.help;
  };

  return HelpFormatter;

}).call(this);

RawDescriptionHelpFormatter = (function(_super) {

  __extends(RawDescriptionHelpFormatter, _super);

  function RawDescriptionHelpFormatter() {
    return RawDescriptionHelpFormatter.__super__.constructor.apply(this, arguments);
  }

  /*Help message formatter which retains any formatting in descriptions.
  
  Only the name of this class is considered a public API. All the methods
  provided by the class are considered an implementation detail.
  */


  RawDescriptionHelpFormatter.prototype._fill_text = function(text, width, indent) {
    var line, lines;
    lines = text.split('\n');
    lines = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        _results.push(indent + line);
      }
      return _results;
    })();
    lines = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        _results.push(_.str.rtrim(line));
      }
      return _results;
    })();
    return lines.join('\n');
  };

  return RawDescriptionHelpFormatter;

})(HelpFormatter);

RawTextHelpFormatter = (function(_super) {

  __extends(RawTextHelpFormatter, _super);

  function RawTextHelpFormatter() {
    return RawTextHelpFormatter.__super__.constructor.apply(this, arguments);
  }

  /*Help message formatter which retains formatting of all help text.
  
  Only the name of this class is considered a public API. All the methods
  provided by the class are considered an implementation detail.
  */


  RawTextHelpFormatter.prototype._split_lines = function(text, width) {
    return text.split('\n');
  };

  return RawTextHelpFormatter;

})(RawDescriptionHelpFormatter);

ArgumentDefaultsHelpFormatter = (function(_super) {

  __extends(ArgumentDefaultsHelpFormatter, _super);

  function ArgumentDefaultsHelpFormatter() {
    return ArgumentDefaultsHelpFormatter.__super__.constructor.apply(this, arguments);
  }

  /*Help message formatter which adds default values to argument help.
  
  Only the name of this class is considered a public API. All the methods
  provided by the class are considered an implementation detail.
  */


  ArgumentDefaultsHelpFormatter.prototype._get_help_string = function(action) {
    var defaulting_nargs, help, _ref;
    help = action.help;
    if (action.help.indexOf('%(defaultValue)s') === -1) {
      if (action.defaultValue !== $$.SUPPRESS) {
        defaulting_nargs = [$$.OPTIONAL, $$.ZERO_OR_MORE];
        if (action.isOptional() || (_ref = action.nargs, __indexOf.call(defaulting_nargs, _ref) >= 0)) {
          help += ' (default: %(defaultValue)s)';
        }
      }
    }
    return help;
  };

  return ArgumentDefaultsHelpFormatter;

})(HelpFormatter);

exports.RawDescriptionHelpFormatter = RawDescriptionHelpFormatter;

exports.RawTextHelpFormatter = RawTextHelpFormatter;

exports.ArgumentDefaultsHelpFormatter = ArgumentDefaultsHelpFormatter;

setup = function(parser) {
  var ag, formatter, _i, _len, _ref;
  formatter = new HelpFormatter({
    prog: 'PROG'
  });
  formatter.add_usage(parser.usage, parser._actions, parser._mutually_exclusive_groups);
  formatter.add_text(parser.description);
  _ref = parser._action_groups;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    ag = _ref[_i];
    formatter.start_section(ag.title);
    formatter.add_text(ag.description);
    formatter.add_arguments(ag._group_actions);
    formatter.end_section();
  }
  return formatter;
};

if (module.parent == null) {
  ap = require('./argcoffee').ArgumentParser;
  parser = new ap({
    prog: 'PROG',
    debug: true
  });
  parser.add_argument('-f', '--foo', {
    help: 'foo help'
  });
  parser.add_argument('boo', {
    help: 'boo help',
    nargs: 1
  });
  parser.add_argument('baz', {
    nargs: '+'
  });
  console.log(parser.format_help());
  formatter = new HelpFormatter({
    prog: 'PROG'
  });
  formatter.add_usage(parser.usage, parser._actions, []);
  formatter.add_text('a description %(prog)s');
  console.log('format_help\n', formatter.format_help());
  _ref = parser._action_groups;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    ag = _ref[_i];
    formatter.start_section(ag.title);
    formatter.add_text(ag.description);
    formatter.add_arguments(ag._group_actions);
    formatter.end_section();
  }
  DEBUG('');
  console.log('format_help\n', formatter.format_help());
  console.log('=============================================');
  console.log('help wrapping');
  parser = new ap({
    prog: 'PROG',
    debug: true,
    description: '   oddly    formatted\n' + 'description\n' + '\n' + 'that is so long that it should go onto multiple ' + 'lines when wrapped'
  });
  parser.add_argument('-x', {
    metavar: 'XX',
    help: 'oddly\n' + '    formatted -x help'
  });
  parser.add_argument('y', {
    metavar: 'yyy',
    help: 'normal y help'
  });
  group = parser.add_argument_group({
    title: 'title',
    description: '\n' + '    oddly formatted group\n' + '\n' + 'description'
  });
  group.add_argument('-a', {
    action: 'storeTrue',
    help: ' oddly \n' + 'formatted    -a  help  \n' + '    again, so long that it should be wrapped over ' + 'multiple lines'
  });
  console.log(parser.format_help());
  console.log('------------------');
  formatter = setup(parser);
  console.log('format_help\n', formatter.format_help());
  console.log('=============================================');
  console.log('test usage wrap');
  ap = require('./argcoffee').ArgumentParser;
  parser = new ap({
    prog: 'PROG',
    debug: true
  });
  parser.add_argument('-f', '--foo', {
    help: 'foo help',
    nargs: 3
  });
  parser.add_argument('--booboo', {
    help: 'booboo help',
    nargs: 4
  });
  parser.add_argument('baz', {
    nargs: '+'
  });
  formatter = setup(parser);
  console.log(parser.format_help());
  console.log('-------------------');
  console.log(formatter.format_help());
  console.log('=============================================');
  console.log('parser with exclusive group');
  parser = new ap({
    prog: 'PROG',
    debug: true
  });
  group = parser.addMutuallyExclusiveGroup({
    required: true
  });
  /(?:)/ || should(the(input(be({
    required: true
  } != null))));
  group.addArgument(['--foo'], {
    action: 'storeTrue',
    help: 'foo help'
  });
  group.addArgument(['--spam'], {
    help: 'spam help'
  });
  group2 = parser.addMutuallyExclusiveGroup({
    required: false
  });
  group2.addArgument(['--soup'], {
    action: 'storeTrue'
  });
  group2.addArgument(['--nuts'], {
    action: 'storeFalse'
  });
  args = parser.parseArgs(['--spam', 'S']);
  DEBUG('xgroup actions:', (function() {
    var _j, _len1, _ref1, _results;
    _ref1 = parser._mutually_exclusive_groups[0]._group_actions;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      x = _ref1[_j];
      _results.push(x.dest);
    }
    return _results;
  })());
  formatter = setup(parser);
  console.log(parser.format_help());
  console.log('-------------------');
  console.log(formatter.format_help());
  console.log('=========================');
  console.log('subparsers');
  HelpFormatter_js = require('./formatter');
  parser = new ap({
    prog: 'PROG',
    debug: true,
    formatter_class: HelpFormatter_js,
    description: 'description with %(prog)s subsitution'
  });
  parser.add_argument('--foo', {
    action: 'storeTrue',
    help: 'foo help'
  });
  subparsers = parser.add_subparsers({
    help: 'sub-command of %(prog)s help'
  });
  parser_a = subparsers.addParser('a', {
    help: 'a help',
    formatter_class: HelpFormatter_js
  });
  parser_a.add_argument('bar', {
    type: 'int',
    help: 'bar help, type: %(type)s'
  });
  parser_b = subparsers.addParser('b', {
    help: 'b help',
    formatter_class: HelpFormatter_js
  });
  parser_b.add_argument('--baz', {
    choices: 'XYZ',
    help: 'baz help, default: %(defaultValue)s',
    defaultValue: 'X'
  });
  console.log(parser.format_help());
  console.log(parser_a.format_help());
  console.log(parser_b.format_help());
  console.log('-------------------');
  formatter = setup(parser);
  console.log(formatter.format_help());
  parser_a.formatter_class = HelpFormatter;
  console.log(parser_a.format_help());
  console.log(parser_b.format_help());
}

if (false) {
  console.log('===============================');
  console.log('choices');
  parser = new ap({
    prog: 'PROG',
    debug: true,
    formatter_class: HelpFormatter_js
  });
  parser.add_argument('foo', {
    type: 'int',
    choices: [5, 6, 7, 8, 9]
  });
  formatter = setup(parser);
  console.log(parser.format_help());
  console.log('-------------------');
  console.log(formatter.format_help());
}
