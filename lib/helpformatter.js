// Generated by CoffeeScript 1.4.0
(function() {
  var $$, ArgumentDefaultsHelpFormatter, DEBUG, HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter, adir, ag, ap, assert, fmtwindent, formatter, parser, path, pformat, util, _, _i, _len, _ref, _textwrap,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (!(module.parent != null)) {
    DEBUG = function() {
      var arg;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      arg.unshift('==> ');
      return console.log.apply(console, arg);
    };
  } else {
    DEBUG = function() {};
  }

  util = require('util');

  assert = require('assert');

  path = require('path');

  _ = require('underscore');

  _.str = require('underscore.string');

  adir = './';

  $$ = require('./const');

  fmtwindent = function(fmt, tup) {
    var i, indent, spc, text, width;
    indent = tup[0], spc = tup[1], text = tup[2], width = tup[3];
    text = ((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= indent ? _i < indent : _i > indent; i = 0 <= indent ? ++_i : --_i) {
        _results.push(spc);
      }
      return _results;
    })()).join('') + text;
    if (width != null) {
      text = _.str.pad(text, width + indent, ' ', 'right');
    }
    return text;
  };

  _textwrap = {
    wrap: function(text, width) {
      return text;
    },
    fill: function(text, width, initial_indent, subsequent_indent) {
      if (initial_indent == null) {
        initial_indent = 0;
      }
      if (subsequent_indent == null) {
        subsequent_indent = 0;
      }
      return text;
    }
  };

  pformat = function(fmt, params) {
    var p, _i, _len;
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      fmt = fmt.replace(/%s/, p);
    }
    return fmt;
  };

  HelpFormatter = (function() {
    /*Formatter for generating usage messages and argument help strings.
    
    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    */

    var _Section;

    function HelpFormatter(options) {
      var indent_increment, max_help_position, prog, width, _ref, _ref1, _ref2, _ref3, _ref4;
      if (options == null) {
        options = {};
      }
      this._format_action_invocation = __bind(this._format_action_invocation, this);

      this._format_action = __bind(this._format_action, this);

      this._format_text = __bind(this._format_text, this);

      this._format_actions_usage = __bind(this._format_actions_usage, this);

      this._format_usage = __bind(this._format_usage, this);

      prog = options.prog;
      indent_increment = (_ref = (_ref1 = options.indent_increment) != null ? _ref1 : options.indentIncrement) != null ? _ref : 2;
      max_help_position = (_ref2 = (_ref3 = options.max_help_position) != null ? _ref3 : options.maxHelpPosition) != null ? _ref2 : 24;
      width = (_ref4 = options.width) != null ? _ref4 : null;
      if (width != null) {
        width = 80 - 2;
      }
      this._prog = prog;
      this._indent_increment = indent_increment;
      this._max_help_position = max_help_position;
      this._width = width;
      this._current_indent = 0;
      this._level = 0;
      this._action_max_length = 0;
      this._root_section = new this._Section(this, null);
      this._current_section = this._root_section;
      this._whitespace_matcher = /\s+/;
      this._long_break_matcher = /\n\n\n+/;
    }

    HelpFormatter.prototype._indent = function() {
      this._current_indent += this._indent_increment;
      return this._level += 1;
    };

    HelpFormatter.prototype._dedent = function() {
      this._current_indent -= this._indent_increment;
      assert(this._current_indent >= 0, 'Indent decreased below 0.');
      return this._level -= 1;
    };

    HelpFormatter.prototype._Section = _Section = (function() {

      function _Section(formatter, parent, heading) {
        if (heading == null) {
          heading = null;
        }
        this.format_help = __bind(this.format_help, this);

        this.formatter = formatter;
        this.parent = parent;
        this.heading = heading;
        this.items = [];
        DEBUG('new Section', this.heading);
      }

      _Section.prototype.format_help = function() {
        var args, current_indent, func, heading, item_help, join;
        if (this.parent != null) {
          this.formatter._indent();
        }
        join = this.formatter._join_parts;
        item_help = join((function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = this.items;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], func = _ref1[0], args = _ref1[1];
            _results.push(func.apply(null, args));
          }
          return _results;
        }).call(this));
        if (this.parent != null) {
          this.formatter._dedent();
        }
        if (item_help.length === 0) {
          return '';
        }
        if (this.heading !== $$.SUPPRESS && this.heading !== null) {
          current_indent = this.formatter._current_indent;
          heading = fmtwindent('%*s%s', [current_indent, ' ', this.heading + ':\n']);
        } else {
          heading = '';
        }
        return join(['\n', heading, item_help, '\n']);
      };

      return _Section;

    })();

    HelpFormatter.prototype._add_item = function(func, args) {
      var _ref;
      DEBUG('add_item', this._current_section.heading, (_ref = args[0]) != null ? _ref.dest : void 0);
      return this._current_section.items.push([func, args]);
    };

    HelpFormatter.prototype.start_section = function(heading) {
      var section;
      this._indent();
      section = new this._Section(this, this._current_section, heading);
      this._add_item(section.format_help, []);
      return this._current_section = section;
    };

    HelpFormatter.prototype.end_section = function() {
      this._current_section = this._current_section.parent;
      return this._dedent();
    };

    HelpFormatter.prototype.add_text = function(text) {
      if (text !== $$.SUPPRESS && (text != null)) {
        return this._add_item(this._format_text, [text]);
      }
    };

    HelpFormatter.prototype.add_usage = function(usage, actions, groups, prefix) {
      var args;
      if (prefix == null) {
        prefix = null;
      }
      if (usage !== $$.SUPPRESS) {
        args = [usage, actions, groups, prefix];
        return this._add_item(this._format_usage, args);
      }
    };

    HelpFormatter.prototype.add_argument = function(action) {
      var action_length, get_invocation, invocation_length, invocations, s, subaction, _i, _len, _ref;
      if (action.help !== $$.SUPPRESS) {
        get_invocation = this._format_action_invocation;
        invocations = [get_invocation(action)];
        _ref = this._indented_subactions(action);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subaction = _ref[_i];
          invocations.push(get_invocation(subaction));
        }
        invocation_length = Math.max((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = invocations.length; _j < _len1; _j++) {
            s = invocations[_j];
            _results.push(s.length);
          }
          return _results;
        })());
        action_length = invocation_length + this._current_indent;
        this._action_max_length = Math.max(this._action_max_length, action_length);
        return this._add_item(this._format_action, [action]);
      }
    };

    HelpFormatter.prototype.add_arguments = function(actions) {
      var action, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = actions.length; _i < _len; _i++) {
        action = actions[_i];
        _results.push(this.add_argument(action));
      }
      return _results;
    };

    HelpFormatter.prototype.format_help = function() {
      var help;
      help = this._root_section.format_help();
      if (help) {
        help = help.replace(this._long_break_matcher, '\n\n');
        help = _.str.strip(help, '\n') + '\n';
      }
      return help;
    };

    HelpFormatter.prototype._join_parts = function(part_strings) {
      var part;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = part_strings.length; _i < _len; _i++) {
          part = part_strings[_i];
          if (part && part !== $$.SUPPRESS) {
            _results.push(part);
          }
        }
        return _results;
      })()).join('');
    };

    HelpFormatter.prototype._format_usage = function(usage, actions, groups, prefix) {
      var action, action_usage, format, optionals, positionals, prog, s, _i, _len;
      DEBUG('_format_usage', usage, actions.length, groups.length);
      if (prefix === null) {
        prefix = 'usage: ';
      }
      if (usage != null) {
        DEBUG(usage);
        usage = usage.replace(/%(prog)/, this._prog);
      } else if (!(usage != null) && actions.length === 0) {
        usage = this._prog;
      } else if (!(usage != null)) {
        prog = this._prog;
        optionals = [];
        positionals = [];
        for (_i = 0, _len = actions.length; _i < _len; _i++) {
          action = actions[_i];
          if (action.optionStrings.length > 0) {
            optionals.push(action);
          } else {
            positionals.push(action);
          }
        }
        format = this._format_actions_usage;
        action_usage = format([].concat(optionals, positionals), groups);
        usage = ((function() {
          var _j, _len1, _ref, _results;
          _ref = [prog, action_usage];
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            s = _ref[_j];
            if (s) {
              _results.push(s);
            }
          }
          return _results;
        })()).join(' ');
        /*  
        # wrap the usage parts if it's too long
        text_width = @_width - @_current_indent
        if prefix.length + usage.length > text_width
        
            # break usage into wrappable parts
            part_regexp = /\(.*?\)+|\[.*?\]+|\S+/g
            opt_usage = format(optionals, groups)
            pos_usage = format(positionals, groups)
              
            opt_parts = opt_usage.match(part_regexp) ? []
            pos_parts = pos_usage.match(part_regexp) ? []
            #opt_parts = _re.findall(part_regexp, opt_usage)
            #pos_parts = _re.findall(part_regexp, pos_usage)
            #assert opt_parts?.join(' ') == opt_usage
            #assert pos_parts?.join(' ') == pos_usage
        
            # helper for wrapping lines
            get_lines = (parts, indent, prefix=null) ->
                lines = []
                line = []
                if prefix?
                    line_len = prefix.length - 1
                else
                    line_len = indent.length - 1
                for part in parts
                    if line_len + 1 + part.length > text_width
                        lines.push(indent + line.join(' '))
                        line = []
                        line_len = indent.length - 1
                    line.push(part)
                    line_len += part.length + 1
                if line
                    lines.push(indent + line.join(' '))
                if prefix?
                    lines[0] = lines[0][indent.length]
                return lines
        
            # if prog is short, follow it with optionals or positionals
            if prefix.length + prog.length <= 0.75 * text_width
                indent = ' ' * (prefix.length + prog.length + 1)
                if opt_parts
                    lines = get_lines([prog].concat(opt_parts), indent, prefix)
                    lines.concat(get_lines(pos_parts, indent))
                else if pos_parts
                    lines = get_lines([prog].concat(pos_parts), indent, prefix)
                else
                    lines = [prog]
        
            # if prog is long, put it on its own line
            else
                indent = fmtwindent('',[prefix.length,' ',''])
                opt_parts.concat(pos_parts)
                parts = opt_parts
                lines = get_lines(parts, indent)
                if lines.length > 1
                    lines = []
                    lines.concat(get_lines(opt_parts, indent))
                    lines.concat(get_lines(pos_parts, indent))
                # lines = [prog] + lines
                lines.unshift(prog)
        
            # join lines into usage
            usage = lines.join('\n')
        */

      }
      return prefix + usage + "\n\n";
    };

    HelpFormatter.prototype._format_actions_usage = function(actions, groups) {
      var action, args_string, defaultValue, group_actions, i, inserts, item, option_string, part, parts, text, _i, _len;
      DEBUG('_format_actions_usage', this._current_indent);
      group_actions = {};
      inserts = {};
      /*
              for group in groups
                  try
                      start = actions.index(group._group_actions[0])
                  catch ValueError
                      continue
                  #else
                  end = start + group._group_actions.length
                  if actions[start...end] == group._group_actions
                      for action in group._group_actions
                          group_actions[action] = true
                      if not group.required
                          if start in inserts
                              inserts[start] += ' ['
                          else
                              inserts[start] = '['
                          inserts[end] = ']'
                      else
                          if start in inserts
                              inserts[start] += ' ('
                          else
                              inserts[start] = '('
                          inserts[end] = ')'
                      for i in range(start + 1, end)
                          inserts[i] = '|'
      */

      parts = [];
      i = -1;
      for (_i = 0, _len = actions.length; _i < _len; _i++) {
        action = actions[_i];
        i++;
        if (action.help === $$.SUPPRESS) {
          parts.push(null);
          if (inserts[i] === '|') {
            delete inserts[i];
          } else if (inserts[i + 1] === '|') {
            delete inserts[i + 1];
          }
        } else if (action.optionStrings.length === 0) {
          part = this._format_args(action, action.dest);
          if (action in group_actions) {
            if (part[0] === '[' && _.last(part) === ']') {
              part = _last(_.rest(part));
            }
          }
          parts.push(part);
        } else {
          option_string = action.optionStrings[0];
          if (action.nargs === 0) {
            part = option_string;
          } else {
            defaultValue = action.dest.toUpperCase();
            args_string = this._format_args(action, defaultValue);
            part = "" + option_string + " " + args_string;
          }
          if (!action.required && !(action in group_actions)) {
            part = "[" + part + "]";
          }
          parts.push(part);
        }
      }
      for (var i = inserts.length-1; i >= 0; --i) {
           if (inserts[i] != null) {
             parts.splice(i, 0, inserts[i]);
           }
         };;

      text = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
          item = parts[_j];
          if (item != null) {
            _results.push(item);
          }
        }
        return _results;
      })();
      text = text.join(' ');
      /*
              open = r'[\[(]'
              close = r'[\])]'
              text = _re.sub(r'(%s) ' % open, r'\1', text)
              text = _re.sub(r' (%s)' % close, r'\1', text)
              text = _re.sub(r'%s *%s' % (open, close), r'', text)
              text = _re.sub(r'\(([^|]*)\)', r'\1', text)
              text = text.strip()
      */

      text = text.replace(/([\[(]) /g,'$1'); // remove spaces
        text = text.replace(/ ([\])])/g,'$1');
        text = text.replace(/\[ *\]/g, ''); // remove empty groups
        text = text.replace(/\( *\)/g, '');
        text = text.replace(/\(([^|]*)\)/g, '$1'); // remove () from single action groups
        text = _.str.strip(text);;

      return text;
    };

    HelpFormatter.prototype._format_text = function(text) {
      var indent, text_width;
      if (__indexOf.call(text, '%(prog)') >= 0) {
        text = text.replace(/\%\(prog\)/, this.prog);
      }
      text_width = this._width - this._current_indent;
      indent = fmtwindent('', [this._current_indent, ' ', '']);
      return this._fill_text(text, text_width, indent) + '\n\n';
    };

    HelpFormatter.prototype._format_action = function(action) {
      var action_header, action_width, help_lines, help_position, help_text, help_width, indent_first, line, parts, subaction, tup, _i, _j, _len, _len1, _ref, _ref1;
      help_position = Math.min(this._action_max_length + 2, this._max_help_position);
      help_width = this._width - help_position;
      action_width = help_position - this._current_indent - 2;
      action_header = this._format_action_invocation(action);
      DEBUG('action header', action_header, action_width, help_position);
      if (!(action.help != null)) {
        action_header = fmtwindent('%*s%s\n', [this.current_indent, ' ', action_header]) + '\n';
      } else if (action_header.length <= action_width) {
        tup = [this._current_indent, ' ', action_header, action_width + 2];
        action_header = fmtwindent('%*s%-*s  ', tup);
        indent_first = 0;
      } else {
        action_header = ftmwindent('%*s%s\n', [this._current_indent, ' ', action_header]) + '\n';
        indent_first = help_position;
      }
      parts = [action_header];
      if (action.help != null) {
        help_text = this._expand_help(action);
        help_lines = this._split_lines(help_text, help_width);
        help_lines = [help_lines];
        parts.push(fmtwindent('%*s%s\n', [indent_first, ' ', help_lines[0]]) + '\n');
        _ref = help_lines.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          parts.push(fmtwindent('%*s%s\n', [help_position, ' ', line]) + '\n');
        }
      } else if (!_.str.endsWith(action_header, '\n')) {
        parts.push('\n');
      }
      _ref1 = this._indented_subactions(action);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        subaction = _ref1[_j];
        parts.push(this._format_action(subaction));
      }
      return this._join_parts(parts);
    };

    HelpFormatter.prototype._format_action_invocation = function(action) {
      var args_string, defaultValue, metavar, option_string, parts, _i, _len, _ref;
      if (action.optionStrings.length === 0) {
        metavar = this._metavar_formatter(action, action.dest)(1)[0];
        return metavar;
      } else {
        parts = [];
        if (action.nargs === 0) {
          parts = parts.concat(action.optionStrings);
        } else {
          defaultValue = action.dest.toUpperCase();
          args_string = this._format_args(action, defaultValue);
          _ref = action.optionStrings;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            option_string = _ref[_i];
            parts.push("" + option_string + " " + args_string);
          }
        }
        return parts.join(', ');
      }
    };

    HelpFormatter.prototype._metavar_formatter = function(action, default_metavar) {
      var choice, choice_strs, format, result;
      if (action.metavar != null) {
        result = action.metavar;
      } else if (action.choices != null) {
        choice_strs = (function() {
          var _i, _len, _ref, _results;
          _ref = action.choices;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            choice = _ref[_i];
            _results.push(str(choice));
          }
          return _results;
        })();
        result = "" + (choice_strs.join(','));
      } else {
        result = default_metavar;
      }
      format = function(tuple_size) {
        var i;
        return (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= tuple_size ? _i < tuple_size : _i > tuple_size; i = 0 <= tuple_size ? ++_i : --_i) {
            _results.push(result);
          }
          return _results;
        })();
      };
      return format;
    };

    HelpFormatter.prototype._format_args = function(action, default_metavar) {
      var formats, get_metavar, i, result;
      get_metavar = this._metavar_formatter(action, default_metavar);
      if (!(action.nargs != null)) {
        result = pformat('%s', get_metavar(1));
      } else if (action.nargs === $$.OPTIONAL) {
        result = pformat('[%s]', get_metavar(1));
      } else if (action.nargs === $$.ZERO_OR_MORE) {
        result = pformat('[%s [%s ...]]', get_metavar(2));
      } else if (action.nargs === $$.ONE_OR_MORE) {
        result = pformat('%s [%s ...]', get_metavar(2));
      } else if (action.nargs === $$.REMAINDER) {
        result = '...';
      } else if (action.nargs === $$.PARSER) {
        result = pformat('%s ...', get_metavar(1));
      } else {
        formats = ((function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = action.nargs; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push('%s');
          }
          return _results;
        })()).join(' ');
        result = pformat(formats, get_metavar(action.nargs));
      }
      return result;
    };

    HelpFormatter.prototype._expand_help = function(action) {
      var c, choices_str, name, params, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      return this._get_help_string(action);
      params = _.clone(action);
      params.prog = this._prog;
      _ref = _.keys(params);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        if (params[name] === $$.SUPPRESS) {
          delete params[name];
        }
      }
      _ref1 = _.keys(params);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        name = _ref1[_j];
        if (((_ref2 = params[name]) != null ? _ref2.__name__ : void 0) != null) {
          params[name] = params[name].__name__;
        }
      }
      if (params.choices != null) {
        choices_str = ((function() {
          var _k, _len2, _ref3, _results;
          _ref3 = params.choices;
          _results = [];
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            c = _ref3[_k];
            _results.push('' + c);
          }
          return _results;
        })()).join(', ');
        params.choices = choices_str;
      }
      return pformat(this._get_help_string(action), params);
    };

    HelpFormatter.prototype._indented_subactions = function(action) {
      var get_subactions;
      if (action._get_subactions != null) {
        get_subactions = action._get_subactions;
        return get_subactions();
      } else {
        return [];
      }
    };

    HelpFormatter.prototype._split_lines = function(text, width) {
      return text;
      text = text.replace(this._whitespace_matcher, ' ');
      text = _.str.strip(text);
      return _textwrap.wrap(text, width);
    };

    HelpFormatter.prototype._fill_text = function(text, width, indent) {
      return text;
      text = _.str.strip(text.replace(this._whitespace_matcher, ' '));
      return _textwrap.fill(text, width, indent, indent);
    };

    HelpFormatter.prototype._get_help_string = function(action) {
      return action.help;
    };

    return HelpFormatter;

  }).call(this);

  RawDescriptionHelpFormatter = (function(_super) {

    __extends(RawDescriptionHelpFormatter, _super);

    function RawDescriptionHelpFormatter() {
      return RawDescriptionHelpFormatter.__super__.constructor.apply(this, arguments);
    }

    /*Help message formatter which retains any formatting in descriptions.
    
    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    */


    RawDescriptionHelpFormatter.prototype._fill_text = function(text, width, indent) {
      var line;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = text.splitlines(true);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push(indent + line);
        }
        return _results;
      })()).join('');
    };

    return RawDescriptionHelpFormatter;

  })(HelpFormatter);

  RawTextHelpFormatter = (function(_super) {

    __extends(RawTextHelpFormatter, _super);

    function RawTextHelpFormatter() {
      return RawTextHelpFormatter.__super__.constructor.apply(this, arguments);
    }

    /*Help message formatter which retains formatting of all help text.
    
    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    */


    RawTextHelpFormatter.prototype._split_lines = function(text, width) {
      return text.splitlines();
    };

    return RawTextHelpFormatter;

  })(RawDescriptionHelpFormatter);

  ArgumentDefaultsHelpFormatter = (function(_super) {

    __extends(ArgumentDefaultsHelpFormatter, _super);

    function ArgumentDefaultsHelpFormatter() {
      return ArgumentDefaultsHelpFormatter.__super__.constructor.apply(this, arguments);
    }

    /*Help message formatter which adds default values to argument help.
    
    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    */


    ArgumentDefaultsHelpFormatter.prototype._get_help_string = function(action) {
      var defaulting_nargs, help, _ref, _ref1;
      help = action.help;
      if (_ref = !'%(default)', __indexOf.call(action.help, _ref) >= 0) {
        if (action.defaultValue !== $$.SUPPRESS) {
          defaulting_nargs = [$$.OPTIONAL, $$.ZERO_OR_MORE];
          if (action.optionStrings || (_ref1 = action.nargs, __indexOf.call(defaulting_nargs, _ref1) >= 0)) {
            help += ' (default: %(default)s)';
          }
        }
      }
      return help;
    };

    return ArgumentDefaultsHelpFormatter;

  })(HelpFormatter);

  if (!(module.parent != null)) {
    ap = require('./argcoffee').ArgumentParser;
    parser = new ap({
      prog: 'PROG',
      debug: true
    });
    parser.add_argument('-f', '--foo', {
      help: 'foo help'
    });
    parser.add_argument('boo', {
      help: 'boo help',
      nargs: 1
    });
    parser.add_argument('baz', {
      nargs: '+'
    });
    console.log(parser.format_help());
    formatter = new HelpFormatter({
      prog: 'PROG'
    });
    formatter.add_usage(parser.usage, parser._actions, []);
    console.log('format_help\n', formatter.format_help());
    _ref = parser._action_groups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ag = _ref[_i];
      formatter.start_section(ag.title);
      DEBUG('add_text');
      formatter.add_text(ag.description);
      DEBUG('add_arg');
      formatter.add_arguments(ag._group_actions);
      DEBUG('end section');
      formatter.end_section();
    }
    DEBUG('');
    console.log('format_help\n', formatter.format_help());
  }

}).call(this);
