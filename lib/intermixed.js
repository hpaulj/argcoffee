// Generated by CoffeeScript 1.6.1
var PARSER, REMAINDER, TEST, argparse, parse_intermixed_args, print, warn, _, _ref,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

argparse = require('argcoffee');

_ref = argparse.Const, PARSER = _ref.PARSER, REMAINDER = _ref.REMAINDER;

_ = require('underscore');

warn = function(msg) {
  return console.log("WARNING", msg);
};

parse_intermixed_args = function(self, args, namespace) {
  var action, extras, group, optionals, positionals, remaining_args, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref1, _ref2, _ref3, _ref4;
  if (args == null) {
    args = null;
  }
  if (namespace == null) {
    namespace = null;
  }
  if (self.usage === null) {
    self.usage = self.format_usage().slice(7);
    console.log(self.usage);
  }
  positionals = self._get_positional_actions();
  if (_.any((function() {
    var _i, _len, _ref1, _results;
    _results = [];
    for (_i = 0, _len = positionals.length; _i < _len; _i++) {
      action = positionals[_i];
      _results.push((_ref1 = action.nargs) === PARSER || _ref1 === REMAINDER);
    }
    return _results;
  })())) {
    self.error('PARSER or REMAINDER in positionals nargs; use parse_known_args');
    warn('PARSER or REMAINDER in positionals nargs; \n\tusing parse_known');
    return self.parse_known_args(args, namespace);
  }
  if (_.any((function() {
    var _i, _len, _ref1, _results;
    _ref1 = self._mutually_exclusive_groups;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      group = _ref1[_i];
      _results.push((function() {
        var _j, _len1, _ref2, _results1;
        _ref2 = group._group_actions;
        _results1 = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          action = _ref2[_j];
          if (__indexOf.call(positionals, action) >= 0) {
            _results1.push(action.dest);
          }
        }
        return _results1;
      })());
    }
    return _results;
  })())) {
    self.error('positional in mutuallyExclusiveGroup; use parse_known_args');
    warn('positional in mutuallyExclusiveGroup; \n\tusing parse_known');
    return self.parse_known_args(args, namespace);
  }
  for (_i = 0, _len = positionals.length; _i < _len; _i++) {
    action = positionals[_i];
    action.save_nargs = action.nargs;
    action.nargs = 0;
  }
  try {
    _ref1 = self.parse_known_args(args, namespace), namespace = _ref1[0], remaining_args = _ref1[1];
    for (_j = 0, _len1 = positionals.length; _j < _len1; _j++) {
      action = positionals[_j];
      if (namespace[action.dest] != null) {
        delete namespace[action.dest];
      }
    }
  } catch (error) {
    warn('error from 1st parse_known');
    throw error;
  } finally {
    for (_k = 0, _len2 = positionals.length; _k < _len2; _k++) {
      action = positionals[_k];
      action.nargs = action.save_nargs;
    }
  }
  warn("1st: " + ("" + namespace) + ", " + remaining_args);
  optionals = self._get_optional_actions();
  for (_l = 0, _len3 = optionals.length; _l < _len3; _l++) {
    action = optionals[_l];
    action.save_required = action.required;
    action.required = false;
  }
  _ref2 = self._mutually_exclusive_groups;
  for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
    group = _ref2[_m];
    group.save_required = group.required;
    group.required = false;
  }
  try {
    _ref3 = self.parse_known_args(remaining_args, namespace), namespace = _ref3[0], extras = _ref3[1];
  } catch (error) {
    throw error;
  } finally {
    for (_n = 0, _len5 = optionals.length; _n < _len5; _n++) {
      action = optionals[_n];
      action.required = action.save_required;
    }
    _ref4 = self._mutually_exclusive_groups;
    for (_o = 0, _len6 = _ref4.length; _o < _len6; _o++) {
      group = _ref4[_o];
      group.required = group.save_required;
    }
  }
  return [namespace, extras];
};

exports.parse_intermixed_args = parse_intermixed_args;

TEST = module.parent == null;

print = console.log;

function split(args) {
  // console.log(args)
  if (args.length===0) {return []};
  return args.split(' ');
};

if (TEST) {
  (function() {
    var args, astr, extras, group, p, parser, parserInt, sp, spp, trials, _i, _j, _len, _len1, _ref1;
    parserInt = argparse.newParser();
    parserInt.add_argument('--foo', {
      dest: 'foo'
    });
    parserInt.add_argument('--bar', {
      dest: 'bar'
    });
    parserInt.add_argument('cmd');
    parserInt.add_argument('rest', {
      nargs: '*'
    });
    trials = ['a b c d --foo x --bar 1', '--foo x a b c d --bar 1', '--foo x --bar 1 a b c d', 'a b --foo x --bar 1 c d', 'a --foo x b --bar 1 c d', 'a --foo x b c --bar 1 d', 'a --foo x b --bar 1 c --error d', 'a --foo x b --error d --bar 1 c', 'a b c', 'a', '--foo 1', '--foo', ''];
    for (_i = 0, _len = trials.length; _i < _len; _i++) {
      astr = trials[_i];
      print(astr);
    }
    print('');
    for (_j = 0, _len1 = trials.length; _j < _len1; _j++) {
      astr = trials[_j];
      try {
        _ref1 = parse_intermixed_args(parserInt, split(astr)), args = _ref1[0], extras = _ref1[1];
        print(args, extras);
      } catch (error) {
        print('argv:', astr);
        print("" + error);
      }
    }
    print('');
    print(parserInt.format_help());
    print('behavior with REMAINDER');
    parserInt = argparse.newParser();
    parserInt.add_argument('-z');
    parserInt.add_argument('x');
    parserInt.add_argument('y', {
      nargs: '...'
    });
    try {
      print(parse_intermixed_args(parserInt, split('X A B -z Z')));
    } catch (error) {
      print("" + error);
      print(parserInt.parse_known_args(split('X A B -z Z')));
    }
    print('\nsubparsers case');
    p = argparse.newParser();
    sp = p.add_subparsers();
    spp = sp.add_parser('cmd');
    spp.add_argument('foo');
    print(p.format_help());
    try {
      print(parse_intermixed_args(p, ['cmd', '1']));
    } catch (error) {
      print("" + error);
      print(p.parse_known_args(['cmd', '1']));
    }
    print('\nrequired opts');
    p = argparse.newParser();
    p.add_argument('req_pos');
    p.add_argument('-req_opt', {
      type: 'int',
      required: true
    });
    try {
      print(p.parse_known_args([]));
    } catch (error) {
      print("" + error);
    }
    try {
      print(parse_intermixed_args(p, []));
    } catch (error) {
      print("" + error);
    }
    print('\nmutually exclusive case');
    parser = argparse.newParser();
    group = parser.add_mutually_exclusive_group({
      required: true
    });
    group.add_argument('--bar', {
      help: 'bar help'
    });
    group.add_argument('--baz', {
      nargs: '?',
      constant: 'Z',
      help: 'baz help'
    });
    try {
      print(parse_intermixed_args(parser, split('--bar X')));
    } catch (error) {
      print("" + error);
      print(parser.parse_known_args(split('--bar X')));
    }
    print('\nmutually exclusive case, both');
    parser = argparse.newParser();
    group = parser.add_mutually_exclusive_group({
      required: true
    });
    group.add_argument('--foo', {
      action: 'storeTrue',
      help: 'FOO'
    });
    group.add_argument('--spam', {
      help: 'SPAM'
    });
    group.add_argument('badger', {
      nargs: '*',
      defaultValue: 'X',
      help: 'BADGER'
    });
    try {
      print(parse_intermixed_args(parser, []));
    } catch (error) {
      print("" + error);
    }
    try {
      print(parser.parse_known_args([]));
    } catch (error) {
      print("" + error);
    }
    print(parser.parse_known_args(split('--foo')));
    try {
      return print(parse_intermixed_args(parser, split('--spam 1')));
    } catch (error) {
      return print(parser.parse_known_args(split('--spam 1')));
    }
  })();
}

"when parse_intermixed_args is used parse_args, test_argparse.py gives\nerrors in :\nTestActionUserDefined\n\nfail in:\nTestMessageContentError";
