// Generated by CoffeeScript 1.6.1
var $$, ArgumentError, ArgumentParser, PARSER, REMAINDER, SUPPRESS, TEST, argparse, assert, header, parse_fallback_args, parse_intermixed_args, parse_known_intermixed_args, print, split, warn, _, _ref,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

argparse = require('argcoffee');

_ref = argparse.Const, PARSER = _ref.PARSER, REMAINDER = _ref.REMAINDER, SUPPRESS = _ref.SUPPRESS;

$$ = argparse.Const;

ArgumentParser = argparse.ArgumentParser;

ArgumentError = argparse.ArgumentError;

assert = require('assert');

_ = require('underscore');

warn = function(msg) {};

parse_intermixed_args = function(args, namespace) {
  var argv, msg, _ref1;
  if (args == null) {
    args = null;
  }
  if (namespace == null) {
    namespace = null;
  }
  _ref1 = this.parse_known_intermixed_args(args, namespace), args = _ref1[0], argv = _ref1[1];
  if (argv.length > 0) {
    msg = "unrecognized arguments: " + (argv.join(' '));
    this.error(msg);
  }
  return args;
};

parse_known_intermixed_args = function(args, namespace, _fallback) {
  var a, action, err, extras, group, optionals, positionals, remaining_args, save_usage, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref1, _ref2, _ref3;
  if (args == null) {
    args = null;
  }
  if (namespace == null) {
    namespace = null;
  }
  if (_fallback == null) {
    _fallback = null;
  }
  positionals = this._get_positional_actions();
  a = (function() {
    var _i, _len, _ref1, _results;
    _results = [];
    for (_i = 0, _len = positionals.length; _i < _len; _i++) {
      action = positionals[_i];
      if ((_ref1 = action.nargs) === $$.PARSER || _ref1 === $$.REMAINDER) {
        _results.push(action);
      }
    }
    return _results;
  })();
  if (_.any(a)) {
    if (_fallback != null) {
      return _fallback(args, namespace);
    } else {
      a = a[0];
      err = new ArgumentError(a, "parse_intermixed_args: positional arg with nargs=" + a.nargs);
      this.error(err);
    }
  }
  a = (function() {
    var _i, _len, _ref1, _results;
    _ref1 = this._mutually_exclusive_groups;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      group = _ref1[_i];
      _results.push((function() {
        var _j, _len1, _ref2, _results1;
        _ref2 = group._group_actions;
        _results1 = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          action = _ref2[_j];
          if (__indexOf.call(positionals, action) >= 0) {
            _results1.push(action.dest);
          }
        }
        return _results1;
      })());
    }
    return _results;
  }).call(this);
  a = _.flatten(a);
  if (_.any(a)) {
    if (_fallback != null) {
      return _fallback(args, namespace);
    } else {
      this.error('parse_intermixed_args: positional in mutuallyExclusiveGroup');
    }
  }
  save_usage = this.usage;
  try {
    if (this.usage === null) {
      this.usage = this.format_usage().slice(7);
    }
    for (_i = 0, _len = positionals.length; _i < _len; _i++) {
      action = positionals[_i];
      action.save_nargs = action.nargs;
      if (true) {
        action.nargs = 0;
      } else {
        action.nargs = $$.SUPPRESS;
        action.save_default = action.defaultValue;
        action.defaultValue = $$.SUPPRESS;
      }
    }
    try {
      args = this.parse_known_args(args, namespace);
      namespace = args[0];
      remaining_args = args[1];
      for (_j = 0, _len1 = positionals.length; _j < _len1; _j++) {
        action = positionals[_j];
        if (action.nargs === 0) {
          delete namespace[action.dest];
        } else {
          if (namespace[action.dest] != null) {
            warn("removing " + action.dest + "=" + namespace[action.dest]);
            delete namespace[action.dest];
          }
        }
      }
    } finally {
      for (_k = 0, _len2 = positionals.length; _k < _len2; _k++) {
        action = positionals[_k];
        action.nargs = action.save_nargs;
        if (true) {
          action.defaultValue = action.save_default;
        }
      }
    }
    optionals = this._get_optional_actions();
    for (_l = 0, _len3 = optionals.length; _l < _len3; _l++) {
      action = optionals[_l];
      action.save_required = action.required;
      action.required = false;
    }
    _ref1 = this._mutually_exclusive_groups;
    for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
      group = _ref1[_m];
      group.save_required = group.required;
      group.required = false;
    }
    try {
      _ref2 = this.parse_known_args(remaining_args, namespace), namespace = _ref2[0], extras = _ref2[1];
    } finally {
      for (_n = 0, _len5 = optionals.length; _n < _len5; _n++) {
        action = optionals[_n];
        action.required = action.save_required;
      }
      _ref3 = this._mutually_exclusive_groups;
      for (_o = 0, _len6 = _ref3.length; _o < _len6; _o++) {
        group = _ref3[_o];
        group.required = group.save_required;
      }
    }
  } finally {
    this.usage = save_usage;
  }
  return [namespace, extras];
};

if (ArgumentParser.prototype.parse_intermixed_args == null) {
  ArgumentParser.prototype.parse_intermixed_args = parse_intermixed_args;
  ArgumentParser.prototype.parse_known_intermixed_args = parse_known_intermixed_args;
}

parse_fallback_args = function(args, namespace) {
  var argv, fallback, msg, _ref1,
    _this = this;
  if (args == null) {
    args = null;
  }
  if (namespace == null) {
    namespace = null;
  }
  fallback = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    warn('fallingback to parse_known_args');
    return _this.parse_known_args.apply(_this, args);
  };
  _ref1 = this.parse_known_intermixed_args(args, namespace, fallback), args = _ref1[0], argv = _ref1[1];
  if (argv.length > 0) {
    msg = "unrecognized arguments: " + (argv.join(' '));
    this.error(msg);
  }
  return args;
};

parse_fallback_args = function(args, namespace) {
  var args1, argv, msg, save_debug, _ref1, _ref2;
  if (args == null) {
    args = null;
  }
  if (namespace == null) {
    namespace = null;
  }
  try {
    save_debug = this.debug;
    this.debug = true;
    _ref1 = this.parse_known_intermixed_args(args, namespace), args1 = _ref1[0], argv = _ref1[1];
  } catch (error) {
    if (error.message.search('parse_intermixed_args') > -1) {
      warn('fallbacking on parse_known_args');
      this.debug = save_debug;
      _ref2 = this.parse_known_args(args, namespace), args1 = _ref2[0], argv = _ref2[1];
    } else {
      throw error;
    }
  } finally {
    this.debug = save_debug;
  }
  if (argv.length > 0) {
    msg = "unrecognized arguments: " + (argv.join(' '));
    this.error(msg);
  }
  return args1;
};

parse_fallback_args = function(args, namespace) {
  var args1, argv, msg, _ref1, _ref2;
  if (args == null) {
    args = null;
  }
  if (namespace == null) {
    namespace = null;
  }
  try {
    _ref1 = this.parse_known_intermixed_args(args, namespace), args1 = _ref1[0], argv = _ref1[1];
  } catch (error) {
    if (error instanceof TypeError) {
      warn('fallbacking on parse_known_args');
      _ref2 = this.parse_known_args(args, namespace), args1 = _ref2[0], argv = _ref2[1];
    } else {
      throw error;
    }
  }
  if (argv.length > 0) {
    msg = "unrecognized arguments: " + (argv.join(' '));
    this.error(msg);
  }
  return args1;
};

ArgumentParser.prototype.parse_fallback_args = parse_fallback_args;

exports.ArgumentParser = ArgumentParser;

TEST = module.parent == null;

print = console.log;

split = require('underscore.string').words;

header = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  console.log.apply(console, args);
  return console.log('=============');
};

if (TEST) {
  (function() {
    var args, argv, astr, group, p, parser, sp, spp, trials, _i, _j, _len, _len1;
    warn = function() {
      var msg;
      msg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return console.log.apply(console, ["WARNING"].concat(__slice.call(msg)));
    };
    parser = argparse.newParser();
    parser.add_argument('--foo', {
      dest: 'foo',
      required: true
    });
    parser.add_argument('--bar', {
      dest: 'bar'
    });
    parser.add_argument('cmd');
    parser.add_argument('rest', {
      nargs: '*',
      type: 'int'
    });
    trials = ['cmd1 1 2 3 --foo x --bar y', '--foo x cmd1 1 2 3 --bar y', '--foo x --bar y cmd1 1 2 3', 'cmd1 1 --foo x --bar y 2 3', 'cmd1 --foo x 1 --bar y 2 3', 'cmd1 --foo x 1 2 --bar y 3', 'cmd1 --foo x 1 --bar y 2 --error 3', 'cmd1 --foo x 1 --error 2 --bar y 3', 'cmd1 1 2', 'cmd1', '--foo 1', '--foo', ''];
    for (_i = 0, _len = trials.length; _i < _len; _i++) {
      astr = trials[_i];
      print(astr);
    }
    print('');
    for (_j = 0, _len1 = trials.length; _j < _len1; _j++) {
      astr = trials[_j];
      print('');
      try {
        args = parser.parse_fallback_args(split(astr));
        print(args);
        assert.deepEqual(args, {
          foo: 'x',
          bar: 'y',
          cmd: 'cmd1',
          rest: [1, 2, 3]
        });
      } catch (error) {
        print("argv: '" + astr + "'");
        print("" + error);
        print(parser.format_usage());
        if (("" + error).search('unrecognized') > -1) {
          print(parser.parse_known_intermixed_args(split(astr)));
        }
      }
    }
    print('');
    print(parser.format_help());
    header('behavior with REMAINDER');
    parser = argparse.newParser();
    parser.add_argument('-z');
    parser.add_argument('x');
    parser.add_argument('y', {
      nargs: '...'
    });
    argv = split('X A B -z Z');
    print(argv);
    print(parser.parse_known_args(argv));
    print(parser.parse_fallback_args(argv));
    header('\nsubparsers case');
    p = argparse.newParser();
    sp = p.add_subparsers();
    spp = sp.add_parser('cmd');
    spp.add_argument('foo');
    print(p.format_help());
    print(p.parse_fallback_args(['cmd', '1']));
    header('\nrequired opts');
    p = argparse.newParser();
    p.add_argument('req_pos');
    p.add_argument('-req_opt', {
      type: 'int',
      required: true
    });
    try {
      print(p.parse_known_args([]));
    } catch (error) {
      print("" + error);
    }
    try {
      print(p.parse_intermixed_args([]));
    } catch (error) {
      print("" + error);
    }
    try {
      print(p.parse_fallback_args([]));
    } catch (error) {
      print("" + error);
    }
    header('\nmutually exclusive case');
    parser = argparse.newParser();
    group = parser.add_mutually_exclusive_group({
      required: true
    });
    group.add_argument('--bar', {
      help: 'bar help'
    });
    group.add_argument('--baz', {
      nargs: '?',
      constant: 'Z',
      help: 'baz help'
    });
    print(parser.parse_args(split('--bar X')));
    print(parser.parse_intermixed_args(split('--bar X')));
    print(parser.parse_fallback_args(split('--bar X')));
    header('\nmutually exclusive case, both');
    parser = argparse.newParser();
    group = parser.add_mutually_exclusive_group({
      required: true
    });
    group.add_argument('--foo', {
      action: 'storeTrue',
      help: 'FOO'
    });
    group.add_argument('--spam', {
      help: 'SPAM'
    });
    group.add_argument('badger', {
      nargs: '*',
      defaultValue: 'X',
      help: 'BADGER'
    });
    try {
      print(parser.parse_intermixed_args([]));
    } catch (error) {
      print("" + error);
    }
    try {
      print(parser.parse_known_args([]));
    } catch (error) {
      print("" + error);
    }
    return print(parser.parse_fallback_args(split('--spam 1')));
  })();
}
