// Generated by CoffeeScript 1.3.3

/*
 * class ArgumentParser
 *
 * Object for parsing command line strings into js objects.
 *
 * Inherited from [[ActionContainer]]
*/


(function() {
  var $$, ActionContainer, ArgumentParser, DEBUG, FileClass, FileType, HelpFormatter, Namespace, Nsp, TEST, action, adir, args, argumentError, argv, assert, c1, c2, childParser, getattr, hasattr, int1, np, parentParser, parser, path, setattr, subparsers, util, _, _ActionsContainer, _ensure_value, _get_action_name,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (!(module.parent != null)) {
    DEBUG = function() {
      var arg;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      arg.unshift('==> ');
      return console.log.apply(console, arg);
    };
  } else {
    DEBUG = function() {};
  }

  util = require('util');

  assert = require('assert');

  path = require('path');

  _ = require('underscore');

  _.str = require('underscore.string');

  adir = './';

  $$ = require('./const');

  if (false) {
    ActionContainer = require(adir + 'action_container');
  } else {
    _ActionsContainer = require('./argcontainer')._ActionsContainer;
  }

  HelpFormatter = require('./formatter');

  if (false) {
    Namespace = require(adir + 'namespace');
  } else {
    Namespace = (function() {

      function Namespace() {}

      return Namespace;

    })();
  }

  Namespace.prototype.isset = function(key) {
    return this[key] != null;
  };

  Namespace.prototype.get = function(key, defaultValue) {
    var _ref;
    return (_ref = this[key]) != null ? _ref : defaultValue;
  };

  Namespace.prototype.set = function(key, value) {
    return this[key] = value;
  };

  Namespace.prototype.repr = function() {
    return 'Namespace' + util.inspect(this);
  };

  if (DEBUG && 0) {
    np = new Namespace();
    console.log(np);
    console.log(np.repr());
    console.log(np.isset('test'));
    console.log(np.get('test', 'default'));
    np.set('test', 'something');
    np.set('foo', null);
    console.log(np.isset('test'));
    console.log(np.get('test', 'default'));
    console.log(np.repr());
  }

  exports.Namespace = Namespace;

  exports.HelpFormatter = HelpFormatter;

  exports.Const = $$;

  exports.Action = require(adir + 'action');

  if (!(_ActionsContainer != null)) {
    _ActionsContainer = (function(_super) {

      __extends(_ActionsContainer, _super);

      function _ActionsContainer() {
        return _ActionsContainer.__super__.constructor.apply(this, arguments);
      }

      return _ActionsContainer;

    })(ActionContainer);
    util.inherits(_ActionsContainer, ActionContainer);
  }

  ArgumentParser = (function(_super) {

    __extends(ArgumentParser, _super);

    function ArgumentParser(options) {
      var acoptions, defaultKey, default_prefix, parent, _i, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      if (options == null) {
        options = {};
      }
      this._match_arguments_partial = __bind(this._match_arguments_partial, this);

      this._match_argument = __bind(this._match_argument, this);

      this.prog = (_ref = options.prog) != null ? _ref : process.argv[0];
      this.usage = (_ref1 = options.usage) != null ? _ref1 : null;
      this.epilog = (_ref2 = options.epilog) != null ? _ref2 : null;
      this.parents = (_ref3 = options.parents) != null ? _ref3 : [];
      this.formatter_class = (_ref4 = options.formatter_class) != null ? _ref4 : HelpFormatter;
      this.fromfile_prefix_chars = (_ref5 = options.fromfile_prefix_chars) != null ? _ref5 : null;
      this.add_help = (_ref6 = (_ref7 = options.addHelp) != null ? _ref7 : options.add_help) != null ? _ref6 : true;
      this.debug = (_ref8 = options.debug) != null ? _ref8 : false;
      this.description = (_ref9 = options.description) != null ? _ref9 : null;
      this.prefix_chars = (_ref10 = (_ref11 = options.prefixChars) != null ? _ref11 : options.prefix_chars) != null ? _ref10 : '-';
      this.argument_default = (_ref12 = (_ref13 = options.argumentDefault) != null ? _ref13 : options.argument_default) != null ? _ref12 : null;
      this.conflict_handler = (_ref14 = options.conflict_handler) != null ? _ref14 : 'error';
      acoptions = {
        description: this.description,
        prefixChars: this.prefix_chars,
        argument_default: this.argument_default,
        conflictHandler: this.conflict_handler
      };
      _ActionsContainer.call(this, acoptions);
      this._positionals = this.addArgumentGroup({
        title: 'Positional arguments'
      });
      this._optionals = this.addArgumentGroup({
        title: 'Optional arguments'
      });
      this._subparsers = null;
      this.register('type', null, function(o) {
        return o;
      });
      this.register('type', 'auto', function(o) {
        return o;
      });
      this.register('type', 'int', function(x) {
        var result;
        result = parseInt(x, 10);
        if (isNaN(result)) {
          throw new TypeError("" + x + " is not a valid integer.");
        }
        return result;
      });
      this.register('type', 'float', function(x) {
        var result;
        result = parseFloat(x, 10);
        if (isNaN(result)) {
          throw new TypeError("" + x + " is not a valid float.");
        }
        return result;
      });
      this.register('type', 'string', function(x) {
        return '' + x;
      });
      default_prefix = __indexOf.call(this.prefix_chars, '-') >= 0 ? '-' : this.prefix_chars[0];
      if (this.add_help) {
        this.addArgument([default_prefix + 'h', default_prefix + default_prefix + 'help'], {
          action: 'help',
          defaultValue: $$.SUPPRESS,
          help: 'Show this help message and exit'
        });
      }
      if (this.version) {
        this.addArgument([default_prefix + 'v', default_prefix + default_prefix + 'version'], {
          action: 'version',
          "default": $$.SUPPRESS,
          version: this.version,
          help: "show program's version number and exit"
        });
      }
      _ref15 = this.parents;
      for (_i = 0, _len = _ref15.length; _i < _len; _i++) {
        parent = _ref15[_i];
        if (this._addContainerActions != null) {
          this._addContainerActions(parent);
        } else {
          this._add_container_actions(parent);
        }
        if (parent._defaults != null) {
          for (defaultKey in parent._defaults) {
            if (parent._defaults[defaultKey] != null) {
              this._defaults[defaultKey] = parent._defaults[defaultKey];
            }
          }
        }
      }
      this;

    }

    ArgumentParser.prototype._get_kwargs = function() {
      var name, names;
      names = ['prog', 'usage', 'description', 'version', 'formatter_class', 'conflict_handler', 'add_help'];
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          _results.push([name, this[name]]);
        }
        return _results;
      }).call(this);
    };

    ArgumentParser.prototype.add_subparsers = function(options) {
      var ParsersClass, action, description, formatter, groups, positionals, title, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      if (this._subparsers != null) {
        this.error('cannot have multiple subparser arguments');
      }
      options.defaultValue = null;
      options.debug = this.debug;
      options.optionStrings = [];
      options.parserClass = options.parserClass || ArgumentParser;
      if ((options.title != null) || (options.description != null)) {
        title = (_ref = options.title) != null ? _ref : 'subcommands';
        description = (_ref1 = options.description) != null ? _ref1 : null;
        delete options.title;
        delete options.description;
        this._subparsers = this.addArgumentGroup({
          title: title,
          description: description
        });
      } else {
        this._subparsers = this._positionals;
      }
      if (!(options.prog != null)) {
        formatter = this._getFormatter();
        positionals = this._get_positional_actions();
        groups = (_ref2 = this._mutuallyExclusiveGroups) != null ? _ref2 : this._mutually_exclusive_groups;
        formatter.addUsage(this.usage, positionals, groups, '');
        options['prog'] = _.str.strip(formatter.formatHelp());
      }
      if (this._popActionClass != null) {
        ParsersClass = this._popActionClass(options, 'parsers');
      } else {
        ParsersClass = this._pop_action_class(options, 'parsers');
      }
      action = new ParsersClass(options);
      DEBUG(action.nargs);
      DEBUG(this._subparsers.__super__);
      if (this._subparsers._add_action != null) {
        this._subparsers._add_action(action);
      } else {
        this._subparsers._add_action(action);
      }
      return action;
    };

    ArgumentParser.prototype._add_action = function(action) {
      if (action.isOptional()) {
        assert(action.optionStrings);
        this._optionals._add_action(action);
      } else {
        this._positionals._add_action(action);
      }
      return action;
    };

    ArgumentParser.prototype._get_optional_actions = function() {
      var action;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this._actions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          action = _ref[_i];
          if (action.isOptional()) {
            _results.push(action);
          }
        }
        return _results;
      }).call(this);
    };

    ArgumentParser.prototype._get_positional_actions = function() {
      var action;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this._actions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          action = _ref[_i];
          if (!action.isOptional()) {
            _results.push(action);
          }
        }
        return _results;
      }).call(this);
    };

    ArgumentParser.prototype.parse_args = function(args, namespace) {
      var argv, msg, _ref;
      if (args == null) {
        args = null;
      }
      if (namespace == null) {
        namespace = null;
      }
      _ref = this.parse_known_args(args, namespace), args = _ref[0], argv = _ref[1];
      if (argv.length > 0) {
        msg = "unrecognized arguments: " + (argv.join(' '));
        this.error(msg);
      }
      return args;
    };

    ArgumentParser.prototype.parse_known_args = function(args, namespace) {
      var action, argv, dest, _default, _i, _len, _ref, _ref1;
      if (args == null) {
        args = null;
      }
      if (namespace == null) {
        namespace = null;
      }
      args = args || process.argv.slice(2);
      namespace = namespace != null ? namespace : new Namespace();
      DEBUG("parse_known_args: '" + this.prog + "'");
      DEBUG('namespace:', namespace.repr());
      _ref = this._actions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        action = _ref[_i];
        DEBUG('action default: ', action.dest, action.defaultValue);
        if (action.dest !== $$.SUPPRESS) {
          if (!namespace.isset(action.dest)) {
            if (action.defaultValue !== $$.SUPPRESS) {
              _default = action.defaultValue;
              if (_.isString(_default)) {
                _default = this._get_value(action, _default);
              }
              namespace.set(action.dest, _default);
            }
          }
        }
      }
      DEBUG('with defaults:', namespace.repr());
      for (dest in this._defaults) {
        if (!namespace.isset(dest)) {
          namespace.set(dest, this._defaults[dest]);
        }
      }
      if (true) {
        DEBUG('initial args', args, namespace.repr());
        _ref1 = this._parse_known_args(args, namespace), namespace = _ref1[0], args = _ref1[1];
        if (namespace.isset($$._UNRECOGNIZED_ARGS_ATTR)) {
          args.push(namespace.get($$._UNRECOGNIZED_ARGS_ATTR));
          namespace.unset($$._UNRECOGNIZED_ARGS_ATTR, null);
        }
        return [namespace, args];
      } else {
        this.error('' + error);
      }
      argv = [];
      return [args, argv];
    };

    ArgumentParser.prototype._parse_known_args = function(arg_strings, namespace) {
      var action, actionConflicts, actionHash, action_used, arg_string, arg_string_pattern, arg_string_pattern_parts, conflicts, consume_optional, consume_positionals, extras, gactions, group, group_actions, i, index, index_keys, key, max_option_string_index, msg, mutex_action, mutex_group, mxgroups, names, next_option_string_index, option_string_indices, option_tuple, pattern, positionals, positionals_end_index, seen_actions, seen_non_default_actions, start_index, stop_index, strings, take_action, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
        _this = this;
      if (this.fromfile_prefix_chars != null) {
        arg_strings = this._read_args_from_files(arg_strings);
        return [namespace, []];
      }
      actionConflicts = {};
      actionHash = function(action) {
        return action.getName();
      };
      mxgroups = (_ref = this._mutuallyExclusiveGroups) != null ? _ref : this._mutually_exclusive_groups;
      for (_i = 0, _len = mxgroups.length; _i < _len; _i++) {
        mutex_group = mxgroups[_i];
        group_actions = (_ref1 = mutex_group._groupActions) != null ? _ref1 : mutex_group._group_actions;
        for (i = _j = 0, _len1 = group_actions.length; _j < _len1; i = ++_j) {
          mutex_action = group_actions[i];
          key = actionHash(mutex_action);
          if (!(actionConflicts[key] != null)) {
            actionConflicts[key] = [];
          }
          conflicts = actionConflicts[key];
          conflicts.push.apply(conflicts, group_actions.slice(0, i));
          conflicts.push.apply(conflicts, group_actions.slice(i + 1));
        }
      }
      option_string_indices = {};
      arg_string_pattern_parts = [];
      for (i = _k = 0, _len2 = arg_strings.length; _k < _len2; i = ++_k) {
        arg_string = arg_strings[i];
        if (arg_string === '--') {
          arg_string_pattern_parts.push('-');
          _ref2 = arg_strings.slice(i + 1);
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            arg_string = _ref2[_l];
            arg_string_pattern_parts.push('A');
          }
          break;
        } else {
          option_tuple = this._parse_optional(arg_string);
          if (option_tuple === null) {
            pattern = 'A';
          } else {
            option_string_indices[i] = option_tuple;
            pattern = 'O';
          }
          arg_string_pattern_parts.push(pattern);
        }
      }
      arg_string_pattern = arg_string_pattern_parts.join('');
      DEBUG('pattern:', arg_string_pattern, _.keys(option_string_indices));
      seen_actions = [];
      seen_non_default_actions = [];
      take_action = function(action, argument_strings, option_string) {
        var actionConflict, argument_values, msg, _len4, _m, _ref3;
        if (option_string == null) {
          option_string = null;
        }
        seen_actions.push(action);
        argument_values = _this._get_values(action, argument_strings);
        DEBUG('take_action, _get values:', argument_strings, argument_values);
        if (argument_values !== action.defaultValue) {
          seen_non_default_actions.push(action);
          key = actionHash(action);
          if (actionConflicts[key] != null) {
            _ref3 = actionConflicts[key];
            for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
              actionConflict = _ref3[_m];
              if (__indexOf.call(seen_non_default_actions, actionConflict) >= 0) {
                msg = "not allowed with argument " + (actionConflict.getName());
                _this.error(action.getName() + ': ' + msg);
              }
            }
          }
        }
        if (argument_values !== $$.SUPPRESS) {
          action.call(_this, namespace, argument_values, option_string);
          DEBUG('taken_action:', action.dest, namespace.repr());
          return DEBUG('    ', argument_values, option_string);
        }
      };
      consume_optional = function(start_index) {
        var action, action_tuples, arg_count, args, char, chars, explicit_arg, match_argument, msg, new_explicit_arg, option_string, optionals_map, selected_patterns, start, stop, _len4, _m, _ref3, _ref4, _ref5;
        option_tuple = option_string_indices[start_index];
        action = option_tuple[0], option_string = option_tuple[1], explicit_arg = option_tuple[2];
        if (action != null) {
          DEBUG('option tuple:', [action.dest, option_string, explicit_arg]);
        }
        match_argument = _this._match_argument;
        action_tuples = [];
        while (true) {
          if (action === null) {
            extras.push(arg_strings[start_index]);
            return start_index + 1;
          }
          if (explicit_arg != null) {
            arg_count = match_argument(action, 'A');
            chars = _this.prefix_chars;
            if (arg_count === 0 && (_ref3 = option_string[1], __indexOf.call(chars, _ref3) < 0)) {
              DEBUG("explicit arg: '" + explicit_arg + "', '" + option_string + "'");
              action_tuples.push([action, [], option_string]);
              char = option_string[0];
              option_string = char + explicit_arg[0];
              new_explicit_arg = explicit_arg.slice(1) || null;
              optionals_map = (_ref4 = _this._optionStringActions) != null ? _ref4 : _this._option_string_actions;
              if (optionals_map[option_string] != null) {
                action = optionals_map[option_string];
                explicit_arg = new_explicit_arg;
              } else {
                msg = "ignored explicit argument " + explicit_arg;
                _this.error(action.getName() + ': ' + msg);
              }
            } else if (arg_count === 1) {
              stop = start_index + 1;
              args = [explicit_arg];
              action_tuples.push([action, args, option_string]);
              break;
            } else {
              msg = "ignored explicit argument " + explicit_arg;
              _this.error(action.getName() + ': ' + msg);
            }
          } else {
            DEBUG('consume optional, push action tuple');
            start = start_index + 1;
            selected_patterns = arg_string_pattern.slice(start);
            DEBUG('    ', start, arg_string_pattern, action.dest);
            arg_count = match_argument(action, selected_patterns);
            stop = start + arg_count;
            args = arg_strings.slice(start, stop);
            action_tuples.push([action, args, option_string]);
            break;
          }
        }
        for (_m = 0, _len4 = action_tuples.length; _m < _len4; _m++) {
          _ref5 = action_tuples[_m], action = _ref5[0], args = _ref5[1], option_string = _ref5[2];
          take_action(action, args, option_string);
        }
        return stop;
      };
      positionals = this._get_positional_actions();
      consume_positionals = function(start_index) {
        var action, arg_count, arg_counts, args, match_partial, selected_pattern, _len4, _m, _ref3, _ref4, _ref5;
        match_partial = _this._match_arguments_partial;
        selected_pattern = arg_string_pattern.slice(start_index);
        DEBUG('cp', selected_pattern);
        arg_counts = match_partial(positionals, selected_pattern);
        DEBUG('arg count:', arg_counts);
        if (arg_counts.length) {
          _ref3 = _.zip(positionals, arg_counts);
          for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
            _ref4 = _ref3[_m], action = _ref4[0], arg_count = _ref4[1];
            DEBUG('zip action:', action.dest);
            DEBUG('zip argcount:', arg_count);
            args = arg_strings.slice(start_index, start_index + arg_count);
            start_index += arg_count;
            DEBUG('take action:', action.dest, args);
            DEBUG(namespace.repr());
            take_action(action, args);
          }
        }
        [].splice.apply(positionals, [0, 9e9].concat(_ref5 = positionals.slice(arg_counts.length))), _ref5;
        return start_index;
      };
      extras = [];
      start_index = 0;
      index_keys = (function() {
        var _len4, _m, _ref3, _results;
        _ref3 = _.keys(option_string_indices);
        _results = [];
        for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
          x = _ref3[_m];
          _results.push(+x);
        }
        return _results;
      })();
      if (index_keys.length > 0) {
        max_option_string_index = Math.max.apply(Math, index_keys);
      } else {
        max_option_string_index = -1;
      }
      DEBUG('index', _.keys(option_string_indices), max_option_string_index);
      while (start_index <= max_option_string_index) {
        next_option_string_index = Math.min.apply(Math, (function() {
          var _len4, _m, _results;
          _results = [];
          for (_m = 0, _len4 = index_keys.length; _m < _len4; _m++) {
            index = index_keys[_m];
            if (index >= start_index) {
              _results.push(index);
            }
          }
          return _results;
        })());
        if (start_index !== next_option_string_index) {
          DEBUG('consume positional:', start_index);
          positionals_end_index = consume_positionals(start_index);
          if (positionals_end_index > start_index) {
            start_index = positionals_end_index;
            continue;
          } else {
            start_index = positionals_end_index;
          }
        }
        if (__indexOf.call(index_keys, start_index) < 0) {
          strings = arg_strings.slice(start_index, next_option_string_index);
          extras.push.apply(extras, strings);
          start_index = next_option_string_index;
        }
        DEBUG('consume optional', start_index);
        start_index = consume_optional(start_index);
      }
      DEBUG('consume positional', start_index);
      stop_index = consume_positionals(start_index);
      extras.push.apply(extras, arg_strings.slice(stop_index));
      if (positionals.length > 0) {
        this.error('too few arguments');
      }
      _ref3 = this._actions;
      for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
        action = _ref3[_m];
        if (action.required) {
          if (__indexOf.call(seen_actions, action) < 0) {
            this.error("argument " + (action.getName()) + " is required");
          }
        }
      }
      action_used = false;
      _ref5 = (_ref4 = this._mutuallyExclusiveGroups) != null ? _ref4 : this._mutually_exclusive_groups;
      for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
        group = _ref5[_n];
        if (group.required) {
          DEBUG('group required');
          gactions = (_ref6 = group._groupActions) != null ? _ref6 : group._group_actions;
          for (_o = 0, _len6 = gactions.length; _o < _len6; _o++) {
            action = gactions[_o];
            if (__indexOf.call(seen_non_default_actions, action) >= 0) {
              action_used = true;
              break;
            }
          }
          if (!action_used) {
            DEBUG('not action used');
            names = (function() {
              var _len7, _p, _results;
              _results = [];
              for (_p = 0, _len7 = gactions.length; _p < _len7; _p++) {
                action = gactions[_p];
                if (action.help !== $$.SUPPRESS) {
                  _results.push(action.getName());
                }
              }
              return _results;
            })();
            msg = "one of the arguments " + (names.join(' ')) + " is required";
            this.error(msg);
          }
        }
      }
      DEBUG([namespace.repr(), extras]);
      return [namespace, extras];
    };

    ArgumentParser.prototype._read_args_from_files = function(arg_strings) {
      return arg_strings;
    };

    ArgumentParser.prototype.convert_arg_line_to_args = function(arg_line) {
      return [arg_line];
    };

    ArgumentParser.prototype._match_argument = function(action, arg_strings_pattern) {
      var args_errors, matches, msg, nargs_pattern, _ref;
      nargs_pattern = this._get_nargs_pattern(action);
      nargs_pattern = '^' + nargs_pattern;
      matches = arg_strings_pattern.match(nargs_pattern);
      DEBUG('match_argument', arg_strings_pattern, nargs_pattern, matches);
      if (!(matches != null)) {
        args_errors = {
          "null": 'expected one argument'
        };
        args_errors[$$.OPTIONAL] = 'expected at most one argument';
        args_errors[$$.ONE_OR_MORE] = 'expected at least one argument';
        msg = (_ref = args_errors[action.nargs]) != null ? _ref : "expected " + action.nargs + " argument(s)";
        this.error(action.getName() + ': ' + msg);
      }
      return matches[1].length;
    };

    ArgumentParser.prototype._match_arguments_partial = function(actions, arg_strings_pattern) {
      var a, action, actions_slice, foo, i, m, pattern, result, string, _i, _ref;
      result = [];
      DEBUG('actions:', (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = actions.length; _i < _len; _i++) {
          a = actions[_i];
          _results.push(a.dest);
        }
        return _results;
      })());
      DEBUG('arg strings pattern:', arg_strings_pattern);
      foo = this._get_nargs_pattern;
      for (i = _i = _ref = actions.length; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        actions_slice = actions.slice(0, i);
        pattern = ((function() {
          var _j, _len, _results;
          _results = [];
          for (_j = 0, _len = actions_slice.length; _j < _len; _j++) {
            action = actions_slice[_j];
            _results.push(foo(action));
          }
          return _results;
        })()).join('');
        m = arg_strings_pattern.match('^' + pattern);
        DEBUG('pattern:', pattern);
        DEBUG('matches:', m);
        if (m != null) {
          m = m.slice(1);
          result.push.apply(result, (function() {
            var _j, _len, _results;
            _results = [];
            for (_j = 0, _len = m.length; _j < _len; _j++) {
              string = m[_j];
              _results.push(string.length);
            }
            return _results;
          })());
          break;
        }
      }
      DEBUG('match arguments partial:', result);
      return result;
    };

    ArgumentParser.prototype._parse_optional = function(arg_string) {
      var action, actions, explicit_arg, option_string, option_tuple, option_tuples, options, tup, _ref, _ref1, _ref2;
      assert(this.prefix_chars != null);
      DEBUG('parse opt:', arg_string, this.prefix_chars);
      if (!arg_string) {
        return null;
      }
      if (!(_ref = arg_string[0], __indexOf.call(this.prefix_chars, _ref) >= 0)) {
        return null;
      }
      actions = (_ref1 = this._optionStringActions) != null ? _ref1 : this._option_string_actions;
      if (actions[arg_string] != null) {
        action = actions[arg_string];
        return [action, arg_string, null];
      }
      if (arg_string.length === 1) {
        return null;
      }
      if (__indexOf.call(arg_string, '=') >= 0) {
        _ref2 = arg_string.split('='), option_string = _ref2[0], explicit_arg = _ref2[1];
        if (actions[option_string] != null) {
          action = actions[option_string];
          return [action, option_string, explicit_arg];
        }
      }
      option_tuples = this._get_option_tuples(arg_string);
      DEBUG('get opt tuples', arg_string, option_tuples.length);
      if (option_tuples.length > 1) {
        options = (function() {
          var _i, _len, _ref3, _results;
          _results = [];
          for (_i = 0, _len = option_tuples.length; _i < _len; _i++) {
            _ref3 = option_tuples[_i], action = _ref3[0], option_string = _ref3[1], explicit_arg = _ref3[2];
            _results.push(option_string);
          }
          return _results;
        })();
        options = options.join(', ');
        tup = [arg_string, options];
        this.error("ambiguous option: " + arg_string + " could match " + options);
      } else if (option_tuples.length === 1) {
        option_tuple = option_tuples[0];
        return option_tuple;
      }
      if (arg_string.match(this._negative_number_matcher)) {
        if (!_.any(this._hasNegativeNumberOptionals)) {
          return null;
        }
      }
      if (__indexOf.call(arg_string, ' ') >= 0) {
        return null;
      }
      return [null, arg_string, null];
    };

    ArgumentParser.prototype._get_option_tuples = function(option_string) {
      var action, actions, chars, explicit_arg, option_prefix, result, short_explicit_arg, short_option_prefix, tup, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      result = [];
      chars = this.prefix_chars;
      if ((_ref = option_string[0], __indexOf.call(chars, _ref) >= 0) && (_ref1 = option_string[1], __indexOf.call(chars, _ref1) >= 0)) {
        if (__indexOf.call(option_string, '=') >= 0) {
          _ref2 = option_string.split('='), option_prefix = _ref2[0], explicit_arg = _ref2[1];
        } else {
          option_prefix = option_string;
          explicit_arg = null;
        }
        actions = (_ref3 = this._optionStringActions) != null ? _ref3 : this._option_string_actions;
        for (option_string in actions) {
          if (_.str.startsWith(option_string, option_prefix)) {
            action = actions[option_string];
            tup = [action, option_string, explicit_arg];
            result.push(tup);
          }
        }
      } else if ((_ref4 = option_string[0], __indexOf.call(chars, _ref4) >= 0) && (_ref5 = option_string[1], __indexOf.call(chars, _ref5) < 0)) {
        option_prefix = option_string;
        explicit_arg = null;
        short_option_prefix = option_string.slice(0, 2);
        short_explicit_arg = option_string.slice(2);
        actions = (_ref6 = this._optionStringActions) != null ? _ref6 : this._option_string_actions;
        for (option_string in actions) {
          if (option_string === short_option_prefix) {
            action = actions[option_string];
            tup = [action, option_string, short_explicit_arg];
            result.push(tup);
          } else if (_.str.startsWith(option_string, option_prefix)) {
            action = actions[option_string];
            tup = [action, option_string, explicit_arg];
            result.push(tup);
          }
        }
      } else {
        this.error("unexpected option string: " + option_string);
      }
      return result;
    };

    ArgumentParser.prototype._get_nargs_pattern = function(action) {
      var i, nargs, nargs_pattern;
      nargs = action.nargs;
      if (nargs === null) {
        nargs_pattern = '(-*A-*)';
      } else if (nargs === $$.OPTIONAL) {
        nargs_pattern = '(-*A?-*)';
      } else if (nargs === $$.ZERO_OR_MORE) {
        nargs_pattern = '(-*[A-]*)';
      } else if (nargs === $$.ONE_OR_MORE) {
        nargs_pattern = '(-*A[A-]*)';
      } else if (nargs === $$.REMAINDER) {
        nargs_pattern = '([-AO]*)';
      } else if (nargs === $$.PARSER) {
        nargs_pattern = '(-*A[-AO]*)';
      } else {
        nargs_pattern = "(-*" + (((function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= nargs ? _i < nargs : _i > nargs; i = 0 <= nargs ? ++_i : --_i) {
            _results.push('A');
          }
          return _results;
        })()).join('')) + "-*)";
      }
      if (action.optionStrings.length > 0) {
        nargs_pattern = nargs_pattern.replace(/-\*/g, '');
        nargs_pattern = nargs_pattern.replace(/-/g, '');
      }
      DEBUG(nargs, nargs_pattern);
      return nargs_pattern;
    };

    ArgumentParser.prototype._get_values = function(action, arg_strings) {
      var arg_string, s, v, value, _i, _len, _ref, _ref1;
      DEBUG('_get_values:');
      if ((_ref = action.nargs) !== $$.PARSER && _ref !== $$.REMAINDER) {
        arg_strings = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
            s = arg_strings[_i];
            if (s !== '--') {
              _results.push(s);
            }
          }
          return _results;
        })();
      }
      DEBUG(arg_strings.length, action.nargs, action.optionStrings, action.defaultValue);
      if (arg_strings.length === 0 && action.nargs === $$.OPTIONAL) {
        DEBUG('doing ?');
        if (action.optionStrings.length > 0) {
          value = action.constant;
        } else {
          value = action.defaultValue;
        }
        if (_.isString(value)) {
          value = this._get_value(action, value);
          this._check_value(action, value);
        }
      } else if (arg_strings.length === 0 && action.nargs === $$.ZERO_OR_MORE && action.optionStrings.length === 0) {
        DEBUG('doing *');
        if (action.defaultValue != null) {
          value = action.defaultValue;
        } else {
          value = arg_strings;
          DEBUG(value);
        }
        this._check_value(action, value);
      } else if (arg_strings.length === 1 && ((_ref1 = action.nargs) === null || _ref1 === $$.OPTIONAL)) {
        arg_string = arg_strings[0];
        value = this._get_value(action, arg_string);
        this._check_value(action, value);
      } else if (action.nargs === $$.REMAINDER) {
        value = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
            v = arg_strings[_i];
            _results.push(this._get_value(action, v));
          }
          return _results;
        }).call(this);
      } else if (action.nargs === $$.PARSER) {
        value = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
            v = arg_strings[_i];
            _results.push(this._get_value(action, v));
          }
          return _results;
        }).call(this);
        DEBUG('value from subparse', value);
        this._check_value(action, value[0]);
      } else {
        value = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
            v = arg_strings[_i];
            _results.push(this._get_value(action, v));
          }
          return _results;
        }).call(this);
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          v = value[_i];
          this._check_value(action, v);
        }
      }
      return value;
    };

    ArgumentParser.prototype._get_value = function(action, arg_string) {
      var msg, result, type_func;
      type_func = this._registryGet('type', action.type, action.type);
      if (!_.isFunction(type_func)) {
        msg = "" + type_func + " is not callable";
        this.error(action.getName() + ': ' + msg);
      }
      try {
        result = type_func(arg_string);
      } catch (error) {
        this.error(error);
      }
      /*    
      # ArgumentTypeErrors indicate errors
      except ArgumentTypeError:
          name = getattr(action.type, '__name__', repr(action.type))
          msg = str(_sys.exc_info()[1])
          throw argumentError(action, msg)
      
      # TypeErrors or ValueErrors also indicate errors
      except (TypeError, ValueError):
          name = getattr(action.type, '__name__', repr(action.type))
          msg = _('invalid %s value: %r')
          throw argumentError(action, msg % (name, arg_string))
      */

      return result;
    };

    ArgumentParser.prototype._check_value = function(action, value) {
      var choices, msg;
      if (action.choices != null) {
        if (_.isString(action.choices)) {
          choices = action.choices;
        } else if (_.isArray(action.choices)) {
          choices = action.choices;
        } else if (_.isObject(action.choices)) {
          choices = _.keys(action.choices);
        }
        if (__indexOf.call(choices, value) < 0) {
          msg = "invalid choice: " + value + " (choose from " + choices + ")";
          return this.error(action.getName() + ': ' + msg);
        }
      }
    };

    /*
        # argument_parser.js has more elaborate checkvalue
            ArgumentParser.prototype._checkValue = function (action, value) {
          // converted value must be one of the choices (if specified)
          var choices = action.choices;
          if (!!choices) {
            // choise for argument can by array or string
            if ((_.isString(choices) || _.isArray(choices)) &&
                choices.indexOf(value) !== -1) {
              return;
            }
            // choise for subparsers can by only hash
            if (_.isObject(choices) && !_.isArray(choices) && choices[value]) {
              return;
            }
          
            if (_.isString(choices)) {
              choices = choices.split('').join(', ');
            }
            else if (_.isArray(choices)) {
              choices =  choices.join(', ');
            }
            else {
              choices =  _.keys(choices).join(', ');
            }
            var message = _.str.sprintf(
              'Invalid choice: %(value)s (choose from [%(choices)s])',
              {value: value, choices: choices}
            );
            throw argumentError(action, message);
          }
        };
    */


    ArgumentParser.prototype.format_usage = function() {
      var formatter;
      formatter = this._getFormatter();
      formatter.addUsage(this.usage, this._actions, this._mutually_exclusive_groups);
      return formatter.formatHelp();
    };

    ArgumentParser.prototype.formatUsage = function() {
      return this.format_usage();
    };

    ArgumentParser.prototype.format_help = function() {
      var actionGroup, formatter, _i, _len, _ref, _ref1, _ref2;
      formatter = this._getFormatter();
      formatter.addUsage(this.usage, this._actions, this._mutually_exclusive_groups);
      formatter.addText(this.description);
      _ref1 = (_ref = this._actionGroups) != null ? _ref : this._action_groups;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        actionGroup = _ref1[_i];
        formatter.startSection(actionGroup.title);
        formatter.addText(actionGroup.description);
        formatter.addArguments((_ref2 = actionGroup._groupActions) != null ? _ref2 : actionGroup._group_actions);
        formatter.endSection();
      }
      formatter.addText(this.epilog);
      return formatter.formatHelp();
    };

    ArgumentParser.prototype.formatHelp = function() {
      return this.format_help();
    };

    ArgumentParser.prototype._getFormatter = function() {
      var FormatterClass, formatter;
      FormatterClass = this.formatter_class;
      return formatter = new FormatterClass({
        prog: this.prog
      });
    };

    ArgumentParser.prototype.printUsage = function() {
      return this._printMessage(this.format_usage());
    };

    ArgumentParser.prototype.print_usage = function() {
      return this.printUsage();
    };

    ArgumentParser.prototype.printHelp = function() {
      return this._printMessage(this.format_help());
    };

    ArgumentParser.prototype.print_help = function() {
      return this.printHelp();
    };

    ArgumentParser.prototype.error = function(err) {
      var message, msg;
      assert(this.debug != null, '@ error in @error');
      if (err instanceof Error) {
        if (this.debug) {
          throw err;
        }
        message = err.message;
      } else {
        message = err;
      }
      msg = "" + this.prog + ": error: " + message + $$.EOL;
      if (this.debug) {
        throw new Error(msg);
      }
      this.print_usage(process.stderr);
      return this.exit(2, msg);
    };

    ArgumentParser.prototype.exit = function(status, message) {
      if (message != null) {
        if (status === 0) {
          this._printMessage(message);
        } else {
          this._printMessage(message, process.stderr);
        }
      }
      if (this.debug) {
        throw new Error('Exit captured');
      } else {
        return process.exit(status);
      }
    };

    ArgumentParser.prototype._printMessage = function(message, stream) {
      if (stream == null) {
        stream = process.stdout;
      }
      if (message) {
        return stream.write('' + message);
      }
    };

    ArgumentParser.prototype.parseArgs = function(args, namespace) {
      if (namespace == null) {
        namespace = null;
      }
      return this.parse_args(args, namespace);
    };

    ArgumentParser.prototype.parseKnownArgs = function(args, namespace) {
      if (namespace == null) {
        namespace = null;
      }
      return this.parse_known_args(args, namespace);
    };

    ArgumentParser.prototype.addSubparsers = function(args) {
      return this.add_subparsers(args);
    };

    if (!(ArgumentParser.prototype.add_argument != null)) {
      ArgumentParser.prototype.add_argument = function() {
        var args, options, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), options = arguments[_i++];
        if (_.isString(options)) {
          args.push(options);
          options = {};
        }
        return this.addArgument(args, options);
      };
    }

    return ArgumentParser;

  })(_ActionsContainer);

  _get_action_name = function(argument) {
    var _ref, _ref1;
    if (argument === null) {
      return null;
    } else if (argument.optionStrings.length > 0) {
      return argument.optionStrings.join('/');
    } else if ((_ref = argument.metavar) !== null && _ref !== $$.SUPPRESS) {
      return argument.metavar;
    } else if ((_ref1 = argument.dest) !== null && _ref1 !== $$.SUPPRESS) {
      return argument.dest;
    } else {
      return null;
    }
  };

  exports.ArgumentParser = ArgumentParser;

  /*
  used as base for Namespace; appears to do the same as JS object display
  class _AttributeHolder(object):
      """Abstract base class that provides __repr__.
  
      The __repr__ method returns a string in the format::
          ClassName(attr=name, attr=name, ...)
      The attributes are determined either by a class-level attribute,
      '_kwarg_names', or by inspecting the instance __dict__.
      """
  
      def __repr__(self):
          type_name = type(self).__name__
          arg_strings = []
          for arg in self._get_args():
              arg_strings.append(repr(arg))
          for name, value in self._get_kwargs():
              arg_strings.append('%s=%r' % (name, value))
          return '%s(%s)' % (type_name, ', '.join(arg_strings))
  
      def _get_kwargs(self):
          return sorted(self.__dict__.items())
  
      def _get_args(self):
          return []
  */


  _ensure_value = function(namespace, name, value) {
    if (getattr(namespace, name, null) === null) {
      setattr(namespace, name, value);
    }
    return getattr(namespace, name);
  };

  getattr = function(obj, key, defaultValue) {
    var _ref;
    return (_ref = obj[key]) != null ? _ref : defaultValue;
  };

  setattr = function(obj, key, value) {
    return obj[key] = value;
  };

  hasattr = function(obj, key) {
    return obj[key] != null;
  };

  FileClass = (function() {
    /*Factory for creating file object types
    
    Instances of FileType are typically passed as type= arguments to the
    ArgumentParser add_argument() method.
    
    Keyword Arguments:
        - mode -- A string indicating how the file is to be opened. Accepts the
            same values as the builtin open() function.
        - bufsize -- The files desired buffer size. Accepts the same values as
            the builtin open() function.
    */

    var fs;

    fs = require('fs');

    function FileClass(mode) {
      this.mode = mode != null ? mode : 'r';
    }

    FileClass.prototype.call = function(string) {
      var msg, openfn;
      openfn = fs.openSync;
      if (string === '-') {
        if (__indexOf.call(this.mode, 'r') >= 0) {
          return process.stdin;
        } else if (__indexOf.call(this.mode, 'w') >= 0) {
          return process.stdout;
        } else {
          msg = "argument '-' with mode " + this.mode;
          this.error(msg);
        }
      }
      return openfn(string, this.mode);
    };

    return FileClass;

  })();

  FileType = function(mode) {
    var fn, ft;
    ft = new FileClass(mode);
    fn = function(string) {
      return ft.call(string);
    };
    return fn;
  };

  exports.FileType = FileType;

  argumentError = function(argument, message) {
    var ERR_CODE, argumentName, err, errMessage;
    ERR_CODE = 'ARGError';
    if (argument.getName != null) {
      argumentName = argument.getName();
    } else {
      argumentName = '' + argument;
    }
    if (argumentName != null) {
      errMessage = "argument '" + argumentName + "': " + message;
    } else {
      errMessage = "" + message;
    }
    err = new TypeError(errMessage);
    err.code = ERR_CODE;
    return err;
  };

  TEST = !(module.parent != null);

  if (TEST && 0) {
    parser = new ArgumentParser();
    parser.format_help();
    parser.add_subparsers({});
    console.log('class:', console.log(ArgumentParser));
    console.log('proto');
    console.log(ArgumentParser.prototype);
    console.log(ArgumentParser.prototype.constructor.super_);
    console.log(ArgumentParser.prototype.constructor.__super__);
    console.log('=====================================');
  }

  if (TEST && 0) {
    parentParser = new ArgumentParser({
      add_help: false,
      description: 'parent'
    });
    parentParser.addArgument(['--x']);
    parentParser._defaults = {
      x: true
    };
    childParser = new ArgumentParser({
      description: 'child',
      parents: [parentParser]
    });
    childParser.addArgument(['--y']);
    childParser.addArgument(['xxx']);
    console.log(childParser.formatHelp());
    if (0) {
      console.log('parent:', util.inspect(parentParser, false, 0));
      console.log('child:', util.inspect(childParser, false, 0));
      console.log('child optional actions:\n', util.inspect((function() {
        var _i, _len, _ref, _results;
        _ref = childParser._optionals._groupActions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          action = _ref[_i];
          _results.push(action.dest);
        }
        return _results;
      })(), false, 1));
      console.log('child positional actions:\n', util.inspect((function() {
        var _i, _len, _ref, _results;
        _ref = childParser._positionals._groupActions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          action = _ref[_i];
          _results.push(action.dest);
        }
        return _results;
      })(), false, 1));
      console.log('_get_kwargs', parentParser._get_kwargs());
    }
    console.log('=====================================');
  }

  if (TEST && 0) {
    int1 = function(arg) {
      var result;
      result = parseInt(arg, 10);
      if (isNaN(result)) {
        throw new TypeError("" + arg + " is not a valid integer");
      }
      return result;
    };
    parser = new ArgumentParser();
    parser.add_argument('foo', {
      nargs: '*',
      defaultValue: 42
    });
    parser.addArgument(['-x', '--xxx'], {
      action: 'storeTrue'
    });
    parser.addArgument(['-y'], {
      dest: 'yyy',
      nargs: 1
    });
    parser.add_argument('-z', '--zzz', {
      action: 'storeFalse'
    });
    parser.add_argument('-d', {
      defaultValue: 'DEFAULT'
    });
    if (process.argv.length === 2) {
      argv = ['123.5'];
      argv = ['-xz', '123'];
    } else {
      argv = null;
    }
    console.log(parser.parse_known_args(argv));
    args = parser.parseArgs(argv);
    console.log(args);
    console.log(getattr(args, 'pos'));
    console.log(getattr(args, 'foo', 'missing'), hasattr(args, 'foo'));
    setattr(args, 'foo', 'found');
    console.log(getattr(args, 'foo'), args);
    console.log('=====================================');
  }

  if (TEST && 0) {
    parser = new ArgumentParser({
      debug: true
    });
    subparsers = parser.addSubparsers({
      title: 'subcommands',
      dest: 'subcommand_name'
    });
    c1 = subparsers.addParser('c1', {
      aliases: ['co']
    });
    c1.addArgument(['-f', '--foo'], {});
    c1.addArgument(['-b', '--bar'], {});
    c2 = subparsers.addParser('c2', {});
    c2.addArgument(['--baz'], {});
    Nsp = new Namespace();
    Nsp.set('dummy', 'foobar');
    args = parser.parse_args('c1 --foo 5'.split(' '), Nsp);
    args = parser.parseArgs('c1 --foo 5'.split(' '), Nsp);
    console.log(args);
    console.log('=====================================');
  }

  if (TEST && 0) {
    parser = new ArgumentParser({
      debug: true
    });
    parser.addArgument(['-1'], {
      dest: 'one'
    });
    parser.addArgument(['foo'], {
      nargs: '?'
    });
    args = parser.parseArgs(['-1', 'X']);
    assert.equal(args.one, 'X');
    console.log(parser.parseArgs(['-z']));
    console.log(parser.parseArgs(['-2']));
    console.log('=====================================');
  }

  if (TEST && 1) {
    parser = new ArgumentParser({
      debug: true
    });
    parser.addArgument(['-x'], {
      type: 'float'
    });
    parser.addArgument(['-3'], {
      type: 'float',
      dest: 'y'
    });
    parser.addArgument(['z'], {
      nargs: '*'
    });
    args = parser.parse_args(['-2']);
    console.log(args);
  }

}).call(this);
