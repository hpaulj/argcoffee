// Generated by CoffeeScript 1.6.1
/*
coffeescript translation
hpaulj@github

argparse.py
# Author: Steven J. Bethard <steven.bethard@gmail.com>.

Command-line parsing library

This module is an optparse-inspired command-line parsing library that:

    - handles both optional and positional arguments
    - produces highly informative usage messages
    - supports parsers that dispatch to sub-parsers

The following is a simple usage example that sums integers from the
command-line and writes the result to a file::

    parser = argparse.ArgumentParser(
        description='sum the integers at the command line')
    parser.add_argument(
        'integers', metavar='int', nargs='+', type=int,
        help='an integer to be summed')
    parser.add_argument(
        '--log', default=sys.stdout, type=argparse.FileType('w'),
        help='the file where the sum should be written')
    args = parser.parse_args()
    args.log.write('%s' % sum(args.integers))
    args.log.close()

The module contains the following public classes:

    - ArgumentParser -- The main entry point for command-line parsing. As the
        example above shows, the add_argument() method is used to populate
        the parser with actions for optional and positional arguments. Then
        the parse_args() method is invoked to convert the args at the
        command-line into an object with attributes.

    - ArgumentError -- The exception raised by ArgumentParser objects when
        there are errors with the parser actions. Errors raised while
        parsing the command-line are caught by ArgumentParser and emitted
        as command-line messages.

    - FileType -- A factory for defining types of files to be created. As the
        example above shows, instances of FileType are typically passed as
        the type= argument of add_argument() calls.

    - Action -- The base class for parser actions. Typically actions are
        selected by passing strings like 'store_true' or 'append_const' to
        the action= argument of add_argument(). However, for greater
        customization of ArgumentParser actions, subclasses of Action may
        be defined and passed as the action= argument.

    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
        ArgumentDefaultsHelpFormatter -- Formatter classes which
        may be passed as the formatter_class= argument to the
        ArgumentParser constructor. HelpFormatter is the default,
        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
        not to change the formatting for help text, and
        ArgumentDefaultsHelpFormatter adds information about argument defaults
        to the help.

All other classes in this module are considered implementation details.
(Also note that HelpFormatter and RawDescriptionHelpFormatter are only
considered public as object names -- the API of the formatter objects is
still considered an implementation detail.)
*/

var $$, Action, ActionAppend, ActionAppendConstant, ActionCount, ActionHelp, ActionStore, ActionStoreConstant, ActionStoreFalse, ActionStoreTrue, ActionSubparsers, ActionVersion, ArgumentDefaultsHelpFormatter, ArgumentError, ArgumentParser, ArgumentTypeError, DEBUG, FileClass, FileType, HelpFormatter, Namespace, RawDescriptionHelpFormatter, RawTextHelpFormatter, TEST, action, assert, fileType, fmtwindent, getattr, hasattr, path, pformat, pnformat, setattr, util, _, _ActionsContainer, _AppendAction, _AppendConstAction, _ArgumentGroup, _CountAction, _HelpAction, _MutuallyExclusiveGroup, _StoreAction, _StoreConstAction, _StoreFalseAction, _StoreTrueAction, _SubParsersAction, _VersionAction, __repr__, _ensure_value, _get_action_name, _textwrap,
  __hasProp = {}.hasOwnProperty,
  __slice = [].slice,
  _this = this,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

DEBUG = function() {};

util = require('util');

assert = require('assert');

path = require('path');

_ = require('underscore');

_.str = require('underscore.string');

/*
Constants
*/


$$ = {};

$$.EOL = '\n';

$$.SUPPRESS = '==SUPPRESS==';

$$.OPTIONAL = '?';

$$.ZERO_OR_MORE = '*';

$$.ONE_OR_MORE = '+';

$$.PARSER = 'A...';

$$.REMAINDER = '...';

$$._UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args';

__repr__ = function(obj, arglist) {
  var arg, arg_strings, foo, key, type_name, value;
  if (arglist == null) {
    arglist = null;
  }
  foo = function(value) {
    var v, xxx;
    if (_.isString(value)) {
      return "'" + value + "'";
    }
    if (_.isArray(value)) {
      xxx = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          v = value[_i];
          _results.push(foo(v));
        }
        return _results;
      })()).join(', ');
      return "[" + xxx + "]";
    }
    if (_.isFunction(value)) {
      return value.name;
    }
    return value;
  };
  type_name = obj.constructor.name;
  arg_strings = [];
  if (arglist) {
    arg_strings = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arglist.length; _i < _len; _i++) {
        arg = arglist[_i];
        _results.push("" + arg + ": " + (foo(obj[arg])));
      }
      return _results;
    })();
  } else {
    arg_strings = (function() {
      var _results;
      _results = [];
      for (key in obj) {
        if (!__hasProp.call(obj, key)) continue;
        value = obj[key];
        if (value != null) {
          _results.push("" + key + ": " + (foo(value)));
        }
      }
      return _results;
    })();
  }
  return "" + type_name + " {" + (arg_strings.join(', ')) + "}";
};

fmtwindent = function(fmt, tup) {
  var indent, indentstr, spc, text, trailing, width;
  indent = tup[0], text = tup[1], width = tup[2], spc = tup[3];
  spc = spc != null ? spc : ' ';
  text = text != null ? text : '';
  indentstr = new Array(indent + 1).join(spc);
  text = indentstr + text;
  if (width != null) {
    text = _.str.pad(text, width + indent, ' ', 'right');
  }
  trailing = _.str.strRightBack(fmt, 's');
  if (trailing !== fmt) {
    text = text + trailing;
  } else if (_.str.endsWith(fmt, '\n')) {
    text = text + '\n';
  }
  return text;
};

_textwrap = {
  wrap: function(text, width, initial_indent, subsequent_indent) {
    if (initial_indent == null) {
      initial_indent = 0;
    }
    if (subsequent_indent == null) {
      subsequent_indent = 0;
    }
    return [text];
  },
  fill: function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return _textwrap.wrap.apply(_textwrap, args).join('\n');
  }
};

pformat = function(fmt, params) {
  var p, _i, _len;
  for (_i = 0, _len = params.length; _i < _len; _i++) {
    p = params[_i];
    if (fmt.indexOf('%s') < 0) {
      throw new Error('not all arguments converted during string formatting');
    }
    fmt = fmt.replace(/%s/, p);
  }
  if (fmt.indexOf('%s') > -1) {
    throw new Error('not enough arguments for format string');
  }
  return fmt;
};

pnformat = function(fmt, params) {
  var k;
  for (k in params) {
    fmt = fmt.replace("%(" + k + ")s", params[k]);
  }
  return fmt;
};

HelpFormatter = (function() {
  /*
  Formatter for generating usage messages and argument help strings.
  
  Only the name of this class is considered a public API. All the methods
  provided by the class are considered an implementation detail.
  */

  var _Section,
    _this = this;

  function HelpFormatter(options) {
    var indent_increment, max_help_position, prog, width, _ref, _ref1, _ref2, _ref3, _ref4,
      _this = this;
    if (options == null) {
      options = {};
    }
    this._format_action_invocation = function(action) {
      return HelpFormatter.prototype._format_action_invocation.apply(_this, arguments);
    };
    this._format_action = function(action) {
      return HelpFormatter.prototype._format_action.apply(_this, arguments);
    };
    this._format_text = function(text) {
      return HelpFormatter.prototype._format_text.apply(_this, arguments);
    };
    this._format_actions_usage = function(actions, groups) {
      return HelpFormatter.prototype._format_actions_usage.apply(_this, arguments);
    };
    this._format_usage = function(usage, actions, groups, prefix) {
      return HelpFormatter.prototype._format_usage.apply(_this, arguments);
    };
    prog = options.prog;
    indent_increment = (_ref = (_ref1 = options.indent_increment) != null ? _ref1 : options.indentIncrement) != null ? _ref : 2;
    max_help_position = (_ref2 = (_ref3 = options.max_help_position) != null ? _ref3 : options.maxHelpPosition) != null ? _ref2 : 24;
    width = (_ref4 = options.width) != null ? _ref4 : null;
    if (width == null) {
      width = 80 - 2;
    }
    this._prog = prog;
    this._indent_increment = indent_increment;
    this._max_help_position = max_help_position;
    this._width = width;
    this._current_indent = 0;
    this._level = 0;
    this._action_max_length = 0;
    this._root_section = new this._Section(this, null);
    this._current_section = this._root_section;
    this._whitespace_matcher = /\s+/g;
    this._long_break_matcher = /\n\n\n+/g;
    this._prog_matcher = /%\(prog\)s/;
  }

  HelpFormatter.prototype._indent = function() {
    this._current_indent += this._indent_increment;
    return this._level += 1;
  };

  HelpFormatter.prototype._dedent = function() {
    this._current_indent -= this._indent_increment;
    assert(this._current_indent >= 0, 'Indent decreased below 0.');
    return this._level -= 1;
  };

  HelpFormatter.prototype._Section = _Section = (function() {

    function _Section(formatter, parent, heading) {
      var _this = this;
      if (heading == null) {
        heading = null;
      }
      this.format_help = function() {
        return _Section.prototype.format_help.apply(_this, arguments);
      };
      this.formatter = formatter;
      this.parent = parent;
      this.heading = heading;
      this.items = [];
    }

    _Section.prototype.format_help = function() {
      var args, current_indent, func, heading, item_help, join;
      if (this.parent != null) {
        this.formatter._indent();
      }
      join = this.formatter._join_parts;
      item_help = join((function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = this.items;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], func = _ref1[0], args = _ref1[1];
          _results.push(func.apply(null, args));
        }
        return _results;
      }).call(this));
      if (this.parent != null) {
        this.formatter._dedent();
      }
      if (item_help.length === 0) {
        return '';
      }
      if (this.heading !== $$.SUPPRESS && this.heading !== null) {
        current_indent = this.formatter._current_indent;
        heading = fmtwindent('%*s%s:\n', [current_indent, this.heading]);
      } else {
        heading = '';
      }
      return join(['\n', heading, item_help, '\n']);
    };

    return _Section;

  })();

  HelpFormatter.prototype._add_item = function(func, args) {
    return this._current_section.items.push([func, args]);
  };

  HelpFormatter.prototype.start_section = function(heading) {
    var section;
    this._indent();
    section = new this._Section(this, this._current_section, heading);
    this._add_item(section.format_help, []);
    return this._current_section = section;
  };

  HelpFormatter.prototype.startSection = function(heading) {
    return this.start_section(heading);
  };

  HelpFormatter.prototype.end_section = function() {
    this._current_section = this._current_section.parent;
    return this._dedent();
  };

  HelpFormatter.prototype.endSection = function() {
    return this.end_section();
  };

  HelpFormatter.prototype.add_text = function(text) {
    if (text !== $$.SUPPRESS && (text != null)) {
      return this._add_item(this._format_text, [text]);
    }
  };

  HelpFormatter.prototype.addText = function(text) {
    return this.add_text(text);
  };

  HelpFormatter.prototype.add_usage = function(usage, actions, groups, prefix) {
    var args;
    if (prefix == null) {
      prefix = null;
    }
    if (usage !== $$.SUPPRESS) {
      args = [usage, actions, groups, prefix];
      return this._add_item(this._format_usage, args);
    }
  };

  HelpFormatter.prototype.addUsage = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.add_usage.apply(this, args);
  };

  HelpFormatter.prototype.add_argument = function(action) {
    var action_length, invocation_length, invocations, s, subaction, _i, _len, _ref;
    if (action.help !== $$.SUPPRESS) {
      invocations = [this._format_action_invocation(action)];
      if (action._get_subactions != null) {
        _ref = action._get_subactions();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subaction = _ref[_i];
          this._indent();
          invocations.push(this._format_action_invocation(subaction));
          this._dedent();
        }
      }
      invocation_length = Math.max.apply(Math, (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = invocations.length; _j < _len1; _j++) {
          s = invocations[_j];
          _results.push(s.length);
        }
        return _results;
      })());
      action_length = invocation_length + this._current_indent;
      this._action_max_length = Math.max(this._action_max_length, action_length);
      return this._add_item(this._format_action, [action]);
    }
  };

  HelpFormatter.prototype.addArgument = function(action) {
    return this.add_argument(action);
  };

  HelpFormatter.prototype.add_arguments = function(actions) {
    var action, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = actions.length; _i < _len; _i++) {
      action = actions[_i];
      _results.push(this.add_argument(action));
    }
    return _results;
  };

  HelpFormatter.prototype.addArguments = function(actions) {
    return this.add_arguments(actions);
  };

  HelpFormatter.prototype.format_help = function() {
    var help;
    help = this._root_section.format_help();
    if ((help != null) && help.length > 0) {
      help = help.replace(this._long_break_matcher, '\n\n');
      help = _.str.strip(help, '\n') + '\n';
    }
    return help;
  };

  HelpFormatter.prototype.formatHelp = function() {
    return this.format_help();
  };

  HelpFormatter.prototype._join_parts = function(part_strings) {
    var part;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = part_strings.length; _i < _len; _i++) {
        part = part_strings[_i];
        if (part && part !== $$.SUPPRESS) {
          _results.push(part);
        }
      }
      return _results;
    })()).join('');
  };

  HelpFormatter.prototype._format_usage = function(usage, actions, groups, prefix) {
    var action, action_usage, format, get_lines, indent, lines, opt_parts, opt_usage, optionals, part_regexp, parts, pos_parts, pos_usage, positionals, prog, s, text_width, _i, _len, _ref, _ref1;
    if (prefix === null) {
      prefix = 'usage: ';
    }
    if (usage != null) {
      usage = usage.replace(this._prog_matcher, this._prog);
    } else if ((usage == null) && actions.length === 0) {
      usage = this._prog;
    } else if (usage == null) {
      prog = this._prog;
      optionals = [];
      positionals = [];
      for (_i = 0, _len = actions.length; _i < _len; _i++) {
        action = actions[_i];
        if (action.isOptional()) {
          optionals.push(action);
        } else {
          positionals.push(action);
        }
      }
      format = this._format_actions_usage;
      action_usage = format([].concat(optionals, positionals), groups);
      usage = ((function() {
        var _j, _len1, _ref, _results;
        _ref = [prog, action_usage];
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          s = _ref[_j];
          if (s) {
            _results.push(s);
          }
        }
        return _results;
      })()).join(' ');
      text_width = this._width - this._current_indent;
      if (prefix.length + usage.length > text_width) {
        part_regexp = /\(.*?\)+|\[.*?\]+|\S+/g;
        opt_usage = format(optionals, groups);
        pos_usage = format(positionals, groups);
        opt_parts = (_ref = opt_usage.match(part_regexp)) != null ? _ref : [];
        pos_parts = (_ref1 = pos_usage.match(part_regexp)) != null ? _ref1 : [];
        get_lines = function(parts, indent, prefix) {
          var line, line_len, lines, part, _j, _len1;
          if (prefix == null) {
            prefix = null;
          }
          lines = [];
          line = [];
          if (prefix != null) {
            line_len = prefix.length - 1;
          } else {
            line_len = indent.length - 1;
          }
          for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
            part = parts[_j];
            if (line_len + 1 + part.length > text_width) {
              lines.push(indent + line.join(' '));
              line = [];
              line_len = indent.length - 1;
            }
            line.push(part);
            line_len += part.length + 1;
          }
          if (line.length > 0) {
            lines.push(indent + line.join(' '));
          }
          if (prefix != null) {
            lines[0] = lines[0].slice(indent.length);
          }
          return lines;
        };
        if (prefix.length + prog.length <= 0.75 * text_width) {
          indent = fmtwindent('', [prefix.length + prog.length + 1]);
          if (opt_parts.length > 0) {
            lines = [prog].concat(opt_parts);
            lines = get_lines(lines, indent, prefix);
            lines = lines.concat(get_lines(pos_parts, indent));
          } else if (pos_parts.length > 0) {
            lines = [prog].concat(pos_parts);
            lines = get_lines(lines, indent, prefix);
          } else {
            lines = [prog];
          }
        } else {
          indent = fmtwindent('', [prefix.length]);
          opt_parts.concat(pos_parts);
          parts = opt_parts;
          lines = get_lines(parts, indent);
          if (lines.length > 1) {
            lines = [];
            lines.concat(get_lines(opt_parts, indent));
            lines.concat(get_lines(pos_parts, indent));
          }
          lines.unshift(prog);
        }
        usage = lines.join('\n');
      }
    }
    return prefix + usage + "\n\n";
  };

  HelpFormatter.prototype._format_actions_usage = function(actions, groups) {
    var action, args_string, defaultValue, end, group, group_actions, i, inserts, item, k, option_string, pairs, part, parts, start, text, v, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1, _ref2, _ref3;
    group_actions = [];
    inserts = {};
    for (_i = 0, _len = groups.length; _i < _len; _i++) {
      group = groups[_i];
      start = actions.indexOf(group._group_actions[0]);
      end = start + group._group_actions.length;
      if (_.isEqual(actions.slice(start, end), group._group_actions)) {
        _ref = group._group_actions;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          action = _ref[_j];
          group_actions.push(action);
        }
        if (!group.required) {
          if (start in inserts) {
            inserts[start] += ' [';
          } else {
            inserts[start] = '[';
          }
          inserts[end] = ']';
        } else {
          if (start in inserts) {
            inserts[start] += ' (';
          } else {
            inserts[start] = '(';
          }
          inserts[end] = ')';
        }
        for (i = _k = _ref1 = start + 1; _ref1 <= end ? _k < end : _k > end; i = _ref1 <= end ? ++_k : --_k) {
          inserts[i] = '|';
        }
      }
    }
    parts = [];
    for (i = _l = 0, _len2 = actions.length; _l < _len2; i = ++_l) {
      action = actions[i];
      if (action.help === $$.SUPPRESS) {
        parts.push(null);
        if (inserts[i] === '|') {
          delete inserts[i];
        } else if (inserts[i + 1] === '|') {
          delete inserts[i + 1];
        }
      } else if (action.isPositional()) {
        part = this._format_args(action, action.dest);
        if (__indexOf.call(group_actions, action) >= 0) {
          if (part[0] === '[' && _.last(part) === ']') {
            part = part.slice(1, part.length - 1);
          }
        }
        parts.push(part);
      } else {
        option_string = action.option_strings[0];
        if (action.nargs === 0) {
          part = option_string;
        } else {
          defaultValue = action.dest.toUpperCase();
          args_string = this._format_args(action, defaultValue);
          part = "" + option_string + " " + args_string;
        }
        if (!action.required && __indexOf.call(group_actions, action) < 0) {
          part = "[" + part + "]";
        }
        parts.push(part);
      }
    }
    pairs = _.pairs(inserts);
    if (pairs.length > 0) {
      for (i = _m = _ref2 = pairs.length - 1; _ref2 <= 0 ? _m <= 0 : _m >= 0; i = _ref2 <= 0 ? ++_m : --_m) {
        _ref3 = pairs[i], k = _ref3[0], v = _ref3[1];
        if (v != null) {
          parts.splice(k, 0, v);
        }
      }
    }
    text = ((function() {
      var _len3, _n, _results;
      _results = [];
      for (_n = 0, _len3 = parts.length; _n < _len3; _n++) {
        item = parts[_n];
        if (item != null) {
          _results.push(item);
        }
      }
      return _results;
    })()).join(' ');
    text = text.replace(/([\[(]) /g, '$1');
    text = text.replace(/\ ([\])])/g, '$1');
    text = text.replace(/\[ *\]/g, '');
    text = text.replace(/\( *\)/g, '');
    text = text.replace(/\(([^|]*)\)/g, '$1');
    text = _.str.strip(text);
    return text;
  };

  HelpFormatter.prototype._format_text = function(text) {
    var indent, text_width;
    text = text.replace(this._prog_matcher, this._prog);
    text_width = this._width - this._current_indent;
    indent = fmtwindent('', [this._current_indent]);
    return this._fill_text(text, text_width, indent) + '\n\n';
  };

  HelpFormatter.prototype._format_action = function(action) {
    var action_header, action_width, help_lines, help_position, help_text, help_width, indent_first, line, parts, subaction, tup, _i, _j, _len, _len1, _ref, _ref1;
    help_position = Math.min(this._action_max_length + 2, this._max_help_position);
    help_width = this._width - help_position;
    action_width = help_position - this._current_indent - 2;
    action_header = this._format_action_invocation(action);
    if (action.help == null) {
      action_header = fmtwindent('%*s%s\n', [this._current_indent, action_header]);
    } else if (action_header.length <= action_width) {
      tup = [this._current_indent, action_header, action_width];
      action_header = fmtwindent('%*s%-*s  ', tup);
      indent_first = 0;
    } else {
      action_header = fmtwindent('%*s%s\n', [this._current_indent, action_header]);
      indent_first = help_position;
    }
    parts = [action_header];
    if (action.help != null) {
      help_text = this._expand_help(action);
      help_lines = this._split_lines(help_text, help_width);
      parts.push(fmtwindent('%*s%s\n', [indent_first, help_lines[0]]));
      _ref = help_lines.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        parts.push(fmtwindent('%*s%s\n', [help_position, line]));
      }
    } else if (!_.str.endsWith(action_header, '\n')) {
      parts.push('\n');
    }
    if (action._get_subactions != null) {
      _ref1 = action._get_subactions();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        subaction = _ref1[_j];
        this._indent();
        parts.push(this._format_action(subaction));
        this._dedent();
      }
    }
    return this._join_parts(parts);
  };

  HelpFormatter.prototype._format_action_invocation = function(action) {
    var args_string, defaultValue, metavar, option_string, parts, _i, _len, _ref;
    if (action.isPositional()) {
      metavar = this._metavar_formatter(action, action.dest)(1)[0];
      return metavar;
    } else {
      parts = [];
      if (action.nargs === 0) {
        parts = parts.concat(action.option_strings);
      } else {
        defaultValue = action.dest.toUpperCase();
        args_string = this._format_args(action, defaultValue);
        _ref = action.option_strings;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          option_string = _ref[_i];
          parts.push("" + option_string + " " + args_string);
        }
      }
      return parts.join(', ');
    }
  };

  HelpFormatter.prototype._metavar_formatter = function(action, default_metavar) {
    var choices, format, result;
    if (action.metavar != null) {
      result = action.metavar;
    } else if (action.choices != null) {
      if (_.isString(action.choices)) {
        choices = action.choices;
        choices = choices.split(/\W+/);
        if (choices.length === 1) {
          choices = choices[0].split('');
        }
      } else if (_.isArray(action.choices)) {
        choices = action.choices;
      } else if (_.isObject(action.choices)) {
        choices = _.keys(action.choices);
      } else {
        throw new Error('bad choices variable');
      }
      result = "{" + (choices.join(',')) + "}";
    } else {
      result = default_metavar;
    }
    format = function(tuple_size) {
      var i;
      if (_.isArray(result)) {
        return result;
      } else {
        if (tuple_size > 0) {
          return (function() {
            var _i, _results;
            _results = [];
            for (i = _i = 0; 0 <= tuple_size ? _i < tuple_size : _i > tuple_size; i = 0 <= tuple_size ? ++_i : --_i) {
              _results.push(result);
            }
            return _results;
          })();
        } else {
          return [];
        }
      }
    };
    return format;
  };

  HelpFormatter.prototype._format_args = function(action, default_metavar) {
    var formats, get_metavar, i, nargs, result;
    get_metavar = this._metavar_formatter(action, default_metavar);
    nargs = action.nargs;
    if (nargs == null) {
      result = pformat('%s', get_metavar(1));
    } else if (nargs === $$.OPTIONAL) {
      result = pformat('[%s]', get_metavar(1));
    } else if (nargs === $$.ZERO_OR_MORE) {
      result = pformat('[%s [%s ...]]', get_metavar(2));
    } else if (nargs === $$.ONE_OR_MORE) {
      result = pformat('%s [%s ...]', get_metavar(2));
    } else if (nargs === $$.REMAINDER) {
      result = '...';
    } else if (nargs === $$.PARSER) {
      result = pformat('%s ...', get_metavar(1));
    } else {
      if (!isFinite(nargs)) {
        throw new Error("nargs '" + nargs + "' not a valid string or integer");
      }
      if (nargs > 0) {
        formats = ((function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= nargs ? _i < nargs : _i > nargs; i = 0 <= nargs ? ++_i : --_i) {
            _results.push('%s');
          }
          return _results;
        })()).join(' ');
      } else if (nargs < 0) {
        throw new Error("nargs '" + nargs + "' less than 0");
      } else {
        formats = '';
      }
      try {
        result = pformat(formats, get_metavar(nargs));
      } catch (error) {
        throw new Error("length of metavar tuple does not match nargs");
      }
    }
    return result;
  };

  HelpFormatter.prototype._expand_help = function(action) {
    var c, choices_str, name, params, _ref;
    params = _.clone(action);
    params.prog = this._prog;
    for (name in params) {
      if (params[name] === $$.SUPPRESS) {
        delete params[name];
      }
    }
    for (name in params) {
      if (((_ref = params[name]) != null ? _ref.__name__ : void 0) != null) {
        params[name] = params[name].__name__;
      }
    }
    if (params.choices != null) {
      choices_str = ((function() {
        var _i, _len, _ref1, _results;
        _ref1 = params.choices;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          _results.push('' + c);
        }
        return _results;
      })()).join(', ');
      params.choices = choices_str;
    }
    return pnformat(this._get_help_string(action), params);
  };

  HelpFormatter.prototype._indented_subactions = function(action) {};

  HelpFormatter.prototype._split_lines = function(text, width, indent) {
    var cnt, line, lines, wd, wds, _i, _len;
    if (width == null) {
      width = 80;
    }
    if (indent == null) {
      indent = 0;
    }
    text = text.replace(this._whitespace_matcher, ' ');
    text = _.str.strip(text);
    wds = text.split(' ');
    lines = [];
    line = [];
    cnt = 0;
    for (_i = 0, _len = wds.length; _i < _len; _i++) {
      wd = wds[_i];
      if ((cnt + wd.length + 1) < (width - indent)) {
        line.push(wd);
        cnt += wd.length + 1;
      } else {
        lines.push(line.join(' '));
        line = [wd];
        cnt = wd.length + 1;
      }
    }
    lines.push(line.join(' '));
    return lines;
  };

  HelpFormatter.prototype._fill_text = function(text, width, indent) {
    var line;
    if (indent == null) {
      indent = 0;
    }
    text = this._split_lines(text, width, indent);
    text = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = text.length; _i < _len; _i++) {
        line = text[_i];
        _results.push(indent + line);
      }
      return _results;
    })();
    text = text.join('\n');
    return text;
  };

  HelpFormatter.prototype._get_help_string = function(action) {
    return action.help;
  };

  return HelpFormatter;

}).call(this);

RawDescriptionHelpFormatter = (function(_super) {

  __extends(RawDescriptionHelpFormatter, _super);

  function RawDescriptionHelpFormatter() {
    return RawDescriptionHelpFormatter.__super__.constructor.apply(this, arguments);
  }

  /*
  Help message formatter which retains any formatting in descriptions.
  
  Only the name of this class is considered a public API. All the methods
  provided by the class are considered an implementation detail.
  */


  RawDescriptionHelpFormatter.prototype._fill_text = function(text, width, indent) {
    var line, lines;
    lines = text.split('\n');
    lines = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        _results.push(indent + line);
      }
      return _results;
    })();
    lines = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        _results.push(_.str.rtrim(line));
      }
      return _results;
    })();
    return lines.join('\n');
  };

  return RawDescriptionHelpFormatter;

})(HelpFormatter);

RawTextHelpFormatter = (function(_super) {

  __extends(RawTextHelpFormatter, _super);

  function RawTextHelpFormatter() {
    return RawTextHelpFormatter.__super__.constructor.apply(this, arguments);
  }

  /*
  Help message formatter which retains formatting of all help text.
  
  Only the name of this class is considered a public API. All the methods
  provided by the class are considered an implementation detail.
  */


  RawTextHelpFormatter.prototype._split_lines = function(text, width) {
    return text.split('\n');
  };

  return RawTextHelpFormatter;

})(RawDescriptionHelpFormatter);

ArgumentDefaultsHelpFormatter = (function(_super) {

  __extends(ArgumentDefaultsHelpFormatter, _super);

  function ArgumentDefaultsHelpFormatter() {
    return ArgumentDefaultsHelpFormatter.__super__.constructor.apply(this, arguments);
  }

  /*
  Help message formatter which adds default values to argument help.
  
  Only the name of this class is considered a public API. All the methods
  provided by the class are considered an implementation detail.
  */


  ArgumentDefaultsHelpFormatter.prototype._get_help_string = function(action) {
    var defaulting_nargs, help, _ref;
    help = action.help;
    if (action.help.indexOf('%(defaultValue)s') === -1) {
      if (action.defaultValue !== $$.SUPPRESS) {
        defaulting_nargs = [$$.OPTIONAL, $$.ZERO_OR_MORE];
        if (action.isOptional() || (_ref = action.nargs, __indexOf.call(defaulting_nargs, _ref) >= 0)) {
          help += ' (default: %(defaultValue)s)';
        }
      }
    }
    return help;
  };

  return ArgumentDefaultsHelpFormatter;

})(HelpFormatter);

ArgumentTypeError = (function(_super) {

  __extends(ArgumentTypeError, _super);

  /* An error from trying to convert a command line string to a type.
  */


  function ArgumentTypeError(msg) {
    Error.captureStackTrace(this, this);
    this.message = msg || 'Argument Error';
    this.name = 'ArgumentTypeError';
  }

  return ArgumentTypeError;

})(Error);

/*
An error from creating or using an argument (optional or positional).

The string value of this exception is the message, augmented with
information about the argument that caused it.
*/


ArgumentError = (function(_super) {

  __extends(ArgumentError, _super);

  function ArgumentError(argument, message) {
    this.argument = argument != null ? argument : null;
    this.message = message != null ? message : "";
    this.name = "ArgumentError";
    Error.captureStackTrace(this, this);
    try {
      this.argument_name = this.argument.getName();
    } catch (err) {
      this.argument_name = _get_action_name(this.argument);
    }
  }

  ArgumentError.prototype.toString = function() {
    var astr;
    if (this.argument_name != null) {
      astr = "argument \"" + this.argument_name + "\": " + this.message;
    } else {
      astr = "" + this.message;
    }
    return astr = this.name + ': ' + astr;
  };

  return ArgumentError;

})(Error);

_get_action_name = function(argument) {
  var _ref, _ref1;
  if (argument === null) {
    return null;
  } else if (argument.isOptional()) {
    return argument.option_strings.join('/');
  } else if ((_ref = argument.metavar) !== null && _ref !== $$.SUPPRESS) {
    return argument.metavar;
  } else if ((_ref1 = argument.dest) !== null && _ref1 !== $$.SUPPRESS) {
    return argument.dest;
  } else {
    return null;
  }
};

Action = (function() {
  /*
  Information about how to convert command line strings to Python objects.
  
  Action objects are used by an ArgumentParser to represent the information
  needed to parse a single argument from one or more strings from the
  command line. The keyword arguments to the Action constructor are also
  all attributes of Action instances.
  
  Keyword Arguments:
  
      - option_strings -- A list of command-line option strings which
          should be associated with this action.
  
      - dest -- The name of the attribute to hold the created object(s)
  
      - nargs -- The number of command-line arguments that should be
          consumed. By default, one argument will be consumed and a single
          value will be produced.  Other values include:
              - N (an integer) consumes N arguments (and produces a list)
              - '?' consumes zero or one arguments
              - '*' consumes zero or more arguments (and produces a list)
              - '+' consumes one or more arguments (and produces a list)
          Note that the difference between the default and nargs=1 is that
          with the default, a single value will be produced, while with
          nargs=1, a list containing a single value will be produced.
  
      - constant -- The value to be produced if the option is specified and the
          option uses an action that takes no values.
  
      - defaultValue -- The value to be produced if the option is not specified.
  
      - type -- The type which the command-line arguments should be converted
          to, should be one of 'string', 'int', 'float', 'complex' or a
          callable object that accepts a single string argument. If null,
          'string' is assumed.
  
      - choices -- A container of values that should be allowed. If not null,
          after a command-line argument has been converted to the appropriate
          type, an exception will be raised if it is not a member of this
          collection.
  
      - required -- True if the action must always be specified at the
          command line. This is only meaningful for optional command-line
          arguments.
  
      - help -- The help string describing the argument.
  
      - metavar -- The name to be used for the options argument with the
          help string. If null, the 'dest' value will be used as the name.
  */

  function Action(options) {
    var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    this.option_strings = (_ref = options.option_strings) != null ? _ref : [];
    this.dest = (_ref1 = options.dest) != null ? _ref1 : '';
    this.nargs = (_ref2 = options.nargs) != null ? _ref2 : null;
    this.constant = (_ref3 = options.constant) != null ? _ref3 : null;
    this.defaultValue = (_ref4 = options.defaultValue) != null ? _ref4 : null;
    this.type = (_ref5 = options.type) != null ? _ref5 : null;
    this.choices = (_ref6 = options.choices) != null ? _ref6 : null;
    this.required = (_ref7 = options.required) != null ? _ref7 : false;
    this.help = (_ref8 = options.help) != null ? _ref8 : null;
    this.metavar = (_ref9 = options.metavar) != null ? _ref9 : null;
  }

  Action.prototype.repr = function() {
    var arglist, key, value;
    arglist = (function() {
      var _results;
      _results = [];
      for (key in this) {
        if (!__hasProp.call(this, key)) continue;
        value = this[key];
        if (key !== 'container' && (value != null)) {
          _results.push(key);
        }
      }
      return _results;
    }).call(this);
    return __repr__(this, arglist);
  };

  Action.prototype.toString = Action.prototype.repr;

  Action.prototype.__call__ = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    throw new Error(_('.__call__() not defined'));
  };

  Action.prototype.call = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    return this.__call__(parser, namespace, values, option_string = null);
  };

  Action.prototype.getName = function() {
    var _ref, _ref1;
    if (this.option_strings.length > 0) {
      return this.option_strings.join('/');
    } else if ((_ref = this.metavar) != null ? _ref : this.metavar !== $$.SUPPRESS) {
      return this.metavar;
    } else if ((_ref1 = this.dest) != null ? _ref1 : this.dest !== $$.SUPPRESS) {
      return this.dest;
    }
  };

  Action.prototype.getName = function() {
    if (this.option_strings.length > 0) {
      return this.option_strings.join('/');
    } else if (this.metavar !== null && this.metavar !== $$.SUPPRESS) {
      return this.metavar;
    } else if ((this.dest != null) && this.dest !== $$.SUPPRESS) {
      return this.dest;
    } else {
      return null;
    }
  };

  Action.prototype.isOptional = function() {
    return !this.isPositional();
  };

  Action.prototype.isPositional = function() {
    return this.option_strings.length === 0;
  };

  return Action;

})();

_StoreAction = (function(_super) {

  __extends(_StoreAction, _super);

  function _StoreAction(options) {
    if (options.nargs === 0) {
      throw new Error('nargs for store actions must be > 0; if you ' + 'have nothing to store, actions such as store ' + 'true or store constant may be more appropriate');
    }
    if ((options.constant != null) && options.nargs !== $$.OPTIONAL) {
      throw new Error("nargs must be " + $$.OPTIONAL + " to supply constant");
    }
    _StoreAction.__super__.constructor.call(this, options);
  }

  _StoreAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    return namespace.set(this.dest, values);
  };

  return _StoreAction;

})(Action);

_StoreConstAction = (function(_super) {

  __extends(_StoreConstAction, _super);

  function _StoreConstAction(options) {
    var _ref;
    options.nargs = 0;
    if ((_ref = options.constant) == null) {
      options.constant = options["const"];
    }
    if (options.constant == null) {
      throw new Error('StoreConstAction needs a constant parameter');
    }
    _StoreConstAction.__super__.constructor.call(this, options);
  }

  _StoreConstAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    return namespace.set(this.dest, this.constant);
  };

  return _StoreConstAction;

})(Action);

_StoreTrueAction = (function(_super) {

  __extends(_StoreTrueAction, _super);

  function _StoreTrueAction(options) {
    var _ref;
    options.constant = true;
    if ((_ref = options.defaultValue) == null) {
      options.defaultValue = false;
    }
    _StoreTrueAction.__super__.constructor.call(this, options);
  }

  return _StoreTrueAction;

})(_StoreConstAction);

_StoreFalseAction = (function(_super) {

  __extends(_StoreFalseAction, _super);

  function _StoreFalseAction(options) {
    var _ref;
    options.constant = false;
    if ((_ref = options.defaultValue) == null) {
      options.defaultValue = true;
    }
    _StoreFalseAction.__super__.constructor.call(this, options);
  }

  return _StoreFalseAction;

})(_StoreConstAction);

_AppendAction = (function(_super) {

  __extends(_AppendAction, _super);

  function _AppendAction(options) {
    if (options.nargs === 0) {
      throw new Error('nargs for append actions must be > 0; if arg ' + 'strings are not supplying the value to append, ' + 'the append constant action may be more appropriate');
    }
    if ((options.constant != null) && options.nargs !== $$.OPTIONAL) {
      throw new Error("nargs must be " + $$.OPTIONAL + " to supply constant");
    }
    _AppendAction.__super__.constructor.call(this, options);
  }

  _AppendAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var items;
    if (option_string == null) {
      option_string = null;
    }
    items = _.clone(_ensure_value(namespace, this.dest, []));
    items.push(values);
    return namespace.set(this.dest, items);
  };

  return _AppendAction;

})(Action);

_AppendConstAction = (function(_super) {

  __extends(_AppendConstAction, _super);

  function _AppendConstAction(options) {
    var _ref;
    options.nargs = 0;
    if ((_ref = options.constant) == null) {
      options.constant = options["const"];
    }
    if (options.constant != null) {
      _AppendConstAction.__super__.constructor.call(this, options);
    } else {
      throw new Error('constant required for AppendConstAction');
    }
  }

  _AppendConstAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var items;
    if (option_string == null) {
      option_string = null;
    }
    items = _.clone(_ensure_value(namespace, this.dest, []));
    items.push(this.constant);
    return namespace.set(this.dest, items);
  };

  return _AppendConstAction;

})(Action);

_CountAction = (function(_super) {

  __extends(_CountAction, _super);

  function _CountAction(options) {
    options.nargs = 0;
    _CountAction.__super__.constructor.call(this, options);
  }

  _CountAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var new_count;
    if (option_string == null) {
      option_string = null;
    }
    new_count = _ensure_value(namespace, this.dest, 0) + 1;
    return namespace.set(this.dest, new_count);
  };

  return _CountAction;

})(Action);

_HelpAction = (function(_super) {

  __extends(_HelpAction, _super);

  function _HelpAction(options) {
    var _ref, _ref1;
    if ((_ref = options.dest) == null) {
      options.dest = $$.SUPPRESS;
    }
    if ((_ref1 = options.defaultValue) == null) {
      options.defaultValue = $$.SUPPRESS;
    }
    options.nargs = 0;
    _HelpAction.__super__.constructor.call(this, options);
  }

  _HelpAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    parser.print_help();
    if (parser.debug) {
      console.log('Help pseudo exit');
      return parser.exit();
    } else {
      return parser.exit();
    }
  };

  return _HelpAction;

})(Action);

_VersionAction = (function(_super) {

  __extends(_VersionAction, _super);

  function _VersionAction(options) {
    var _ref, _ref1, _ref2, _ref3;
    if ((_ref = options.version) == null) {
      options.version = null;
    }
    if ((_ref1 = options.dest) == null) {
      options.dest = $$.SUPPRESS;
    }
    if ((_ref2 = options.defaultValue) == null) {
      options.defaultValue = $$.SUPPRESS;
    }
    if ((_ref3 = options.help) == null) {
      options.help = "show program's version number and exit";
    }
    _VersionAction.__super__.constructor.call(this, options);
    this.version = options.version;
  }

  _VersionAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var formatter, version;
    if (option_string == null) {
      option_string = null;
    }
    version = this.version;
    if (version == null) {
      version = parser.version;
    }
    formatter = parser._get_formatter();
    formatter.add_text(version);
    return parser.exit(formatter.format_help());
  };

  return _VersionAction;

})(Action);

_SubParsersAction = (function(_super) {
  var _ChoicesPseudoAction;

  __extends(_SubParsersAction, _super);

  _ChoicesPseudoAction = (function(_super1) {

    __extends(_ChoicesPseudoAction, _super1);

    function _ChoicesPseudoAction(name, aliases, help) {
      var dest, metavar, options;
      metavar = dest = name;
      if (aliases.length > 0) {
        metavar += " (" + (aliases.join(', ')) + ")";
      }
      options = {
        option_strings: [],
        dest: name,
        help: help,
        metavar: metavar
      };
      _ChoicesPseudoAction.__super__.constructor.call(this, options);
    }

    return _ChoicesPseudoAction;

  })(Action);

  function _SubParsersAction(options) {
    var _ref, _ref1, _ref2,
      _this = this;
    this._getSubactions = function() {
      return _SubParsersAction.prototype._getSubactions.apply(_this, arguments);
    };
    this._get_subactions = function() {
      return _SubParsersAction.prototype._get_subactions.apply(_this, arguments);
    };
    this._prog_prefix = options.prog;
    this._parser_class = (_ref = options.parser_class) != null ? _ref : options.parserClass;
    this._name_parser_map = {};
    this._choices_actions = [];
    options.dest = (_ref1 = options.dest) != null ? _ref1 : $$.SUPPRESS;
    options.nargs = $$.PARSER;
    options.choices = this._name_parser_map;
    options.required = (_ref2 = options.required) != null ? _ref2 : true;
    _SubParsersAction.__super__.constructor.call(this, options);
    this.debug = options.debug;
  }

  _SubParsersAction.prototype.add_parser = function(name, options) {
    var alias, aliases, choice_action, help, parser, _i, _len, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    if ((_ref = options.prog) == null) {
      options.prog = "" + this._prog_prefix + " " + name;
    }
    if (options.aliases != null) {
      aliases = options.aliases;
      delete options.aliases;
    } else {
      aliases = [];
    }
    if ((_ref1 = options.debug) == null) {
      options.debug = this.debug;
    }
    if (options.help != null) {
      help = options.help;
      delete options.help;
      choice_action = new _ChoicesPseudoAction(name, aliases, help);
      this._choices_actions.push(choice_action);
    }
    parser = new this._parser_class(options);
    this._name_parser_map[name] = parser;
    for (_i = 0, _len = aliases.length; _i < _len; _i++) {
      alias = aliases[_i];
      this._name_parser_map[alias] = parser;
    }
    return parser;
  };

  _SubParsersAction.prototype.addParser = function(name, options) {
    return this.add_parser(name, options);
  };

  _SubParsersAction.prototype._get_subactions = function() {
    return this._choices_actions;
  };

  _SubParsersAction.prototype._getSubactions = function() {
    return this._get_subactions();
  };

  _SubParsersAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var arg_strings, astring, choices, msg, parser_name, _i, _len, _ref, _ref1, _results;
    if (option_string == null) {
      option_string = null;
    }
    parser_name = values[0];
    arg_strings = values.slice(1);
    if (this.dest !== $$.SUPPRESS) {
      namespace.set(this.dest, parser_name);
    }
    parser = (_ref = this._name_parser_map[parser_name]) != null ? _ref : null;
    if (parser === null) {
      choices = _.keys(this._name_parser_map).join(', ');
      msg = "unknown parser " + parse_name + " (choices: " + choices + ")";
      throw new ArgumentError(this, msg);
    }
    _ref1 = parser.parse_known_args(arg_strings, namespace), namespace = _ref1[0], arg_strings = _ref1[1];
    if (arg_strings.length > 0) {
      if (namespace[$$._UNRECOGNIZED_ARGS_ATTR] == null) {
        namespace[$$._UNRECOGNIZED_ARGS_ATTR] = [];
      }
      _results = [];
      for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
        astring = arg_strings[_i];
        _results.push(namespace[$$._UNRECOGNIZED_ARGS_ATTR].push(astring));
      }
      return _results;
    }
  };

  _SubParsersAction.prototype.getName = function() {
    var choices;
    if (this.metavar !== null && this.metavar !== $$.SUPPRESS) {
      return this.metavar;
    } else if ((this.dest != null) && this.dest !== $$.SUPPRESS) {
      return this.dest;
    } else {
      choices = _.keys(this._name_parser_map).join('/');
      return "{" + choices + "}";
    }
  };

  return _SubParsersAction;

})(Action);

action = {};

action.ActionHelp = _HelpAction;

action.ActionAppend = _AppendAction;

action.ActionAppendConstant = _AppendConstAction;

action.ActionCount = _CountAction;

action.ActionStore = _StoreAction;

action.ActionStoreConstant = _StoreConstAction;

action.ActionStoreTrue = _StoreTrueAction;

action.ActionStoreFalse = _StoreFalseAction;

action.ActionVersion = _VersionAction;

action.ActionSubparsers = _SubParsersAction;

FileClass = (function() {
  /*Factory for creating file object types
  
  Instances of FileType are typically passed as type= arguments to the
  ArgumentParser add_argument() method.
  
  Keyword Arguments:
      - mode -- A string indicating how the file is to be opened. Accepts the
          same values as the builtin open() function.
      - bufsize -- The files desired buffer size. Accepts the same values as
          the builtin open() function.
  Python uses mode, nodejs uses 'flags'
  */

  var fs;

  fs = require('fs');

  function FileClass(options) {
    if (_.isString(options)) {
      options = {
        flags: options
      };
    }
    this.options = options;
  }

  FileClass.prototype.call = function(filename) {
    var createStream, fd, flags, msg, stream;
    flags = this.options.flags;
    if (filename === '-') {
      if (__indexOf.call(flags, 'r') >= 0) {
        return process.stdin;
      } else if (__indexOf.call(flags, 'w') >= 0) {
        return process.stdout;
      } else {
        msg = "argument '-' with flags " + flags;
        throw new TypeError(msg);
      }
    }
    if (flags === 'r') {
      createStream = fs.createReadStream;
    } else if (flags === 'w') {
      createStream = fs.createWriteStream;
    } else {
      throw new TypeError('Unknown file flag');
    }
    try {
      fd = fs.openSync(filename, flags);
      this.options.fd = fd;
      stream = createStream(filename, this.options);
    } catch (error) {
      throw new ArgumentTypeError(error.message);
    }
    return stream;
  };

  return FileClass;

})();

FileType = function(options) {
  var fn, ft;
  if (options == null) {
    options = {
      flags: 'r'
    };
  }
  ft = new FileClass(options);
  fn = function(string) {
    return ft.call(string);
  };
  fn.displayName = 'FileType';
  return fn;
};

fileType = function(options) {
  var fn, fs;
  if (options == null) {
    options = {
      flags: 'r'
    };
  }
  fs = require('fs');
  fn = function(filename) {
    var createStream, fd, flags, msg, stream;
    flags = options.flags;
    if (filename === '-') {
      if (__indexOf.call(flags, 'r') >= 0) {
        return process.stdin;
      } else if (__indexOf.call(flags, 'w') >= 0) {
        return process.stdout;
      } else {
        msg = "argument '-' with flags " + flags;
        throw new Error(msg);
      }
    }
    if (flags === 'r') {
      createStream = fs.createReadStream;
    } else if (flags === 'w') {
      createStream = fs.createWriteStream;
    } else {
      throw new TypeError('Unknown file flag');
    }
    try {
      fd = fs.openSync(filename, flags);
      options.fd = fd;
      stream = createStream(filename, options);
    } catch (error) {
      throw error;
    }
    return stream;
  };
  fn.displayName = 'FileType';
  return fn;
};

fileType = function(options) {
  var createStream, flags, fn, fs, msg, std, _ref, _ref1;
  if (options == null) {
    options = {
      flags: 'r'
    };
  }
  fs = require('fs');
  if (_.isString(options)) {
    flags = options;
  } else {
    flags = options.flags;
  }
  if (flags === 'r') {
    _ref = [process.stdin, fs.createReadStream], std = _ref[0], createStream = _ref[1];
  } else if (flags === 'w') {
    _ref1 = [process.stdout, fs.createWriteStream], std = _ref1[0], createStream = _ref1[1];
  } else {
    msg = "argument '-' with flag " + flags;
    throw new TypeError(msg);
  }
  fn = function(filename) {
    var fd, stream;
    if (filename === '-') {
      stream = std;
    } else {
      try {
        fd = fs.openSync(filename, flags);
        options.fd = fd;
        stream = createStream(filename, options);
      } catch (err) {
        msg = "can't open " + filename + ": " + err.message;
        throw ArgumentTypeError(msg);
      }
    }
    return stream;
  };
  fn.displayName = 'FileType';
  return fn;
};

getattr = function(obj, key, defaultValue) {
  var _ref;
  return (_ref = obj[key]) != null ? _ref : defaultValue;
};

setattr = function(obj, key, value) {
  return obj[key] = value;
};

hasattr = function(obj, key) {
  return obj[key] != null;
};

_ensure_value = function(namespace, name, value) {
  if (getattr(namespace, name, null) === null) {
    setattr(namespace, name, value);
  }
  return getattr(namespace, name);
};

if (true) {
  ActionHelp = action.ActionHelp;
  ActionAppend = action.ActionAppend;
  ActionAppendConstant = action.ActionAppendConstant;
  ActionCount = action.ActionCount;
  ActionStore = action.ActionStore;
  ActionStoreConstant = action.ActionStoreConstant;
  ActionStoreTrue = action.ActionStoreTrue;
  ActionStoreFalse = action.ActionStoreFalse;
  ActionVersion = action.ActionVersion;
  ActionSubparsers = action.ActionSubparsers;
}

_ActionsContainer = (function() {

  function _ActionsContainer(options) {
    var _ref,
      _this = this;
    if (options == null) {
      options = {};
    }
    this._handle_conflict_resolve = function(action, conflicting_actions) {
      return _ActionsContainer.prototype._handle_conflict_resolve.apply(_this, arguments);
    };
    this._add_container_actions = function(container) {
      return _ActionsContainer.prototype._add_container_actions.apply(_this, arguments);
    };
    this.description = options.description;
    this.argument_default = options.argument_default;
    this.prefix_chars = (_ref = options.prefixChars) != null ? _ref : options.prefix_chars;
    this.conflict_handler = options.conflict_handler;
    this._registries = {};
    this.register('action', null, ActionStore);
    this.register('action', 'store', ActionStore);
    this.register('action', 'storeConst', ActionStoreConstant);
    this.register('action', 'store_const', ActionStoreConstant);
    this.register('action', 'storeTrue', ActionStoreTrue);
    this.register('action', 'store_true', ActionStoreTrue);
    this.register('action', 'storeFalse', ActionStoreFalse);
    this.register('action', 'store_false', ActionStoreFalse);
    this.register('action', 'append', ActionAppend);
    this.register('action', 'appendConst', ActionAppendConstant);
    this.register('action', 'append_const', ActionAppendConstant);
    this.register('action', 'count', ActionCount);
    this.register('action', 'help', ActionHelp);
    this.register('action', 'version', ActionVersion);
    this.register('action', 'parsers', ActionSubparsers);
    this._get_handler();
    this._actions = [];
    this._option_string_actions = {};
    this._action_groups = [];
    this._mutually_exclusive_groups = [];
    this._defaults = {};
    this._negative_number_matcher = /^-\d+$|^-\d*\.\d+$/;
    this._hasNegativeNumberOptionals = [];
    this;
  }

  _ActionsContainer.prototype.register = function(registry_name, value, object) {
    var registry;
    if (!_.has(this._registries, registry_name)) {
      this._registries[registry_name] = {};
    }
    registry = this._registries[registry_name];
    return registry[value] = object;
  };

  _ActionsContainer.prototype._registry_get = function(registry_name, value, defaultValue) {
    var _ref;
    if (defaultValue == null) {
      defaultValue = null;
    }
    return (_ref = this._registries[registry_name][value]) != null ? _ref : defaultValue;
  };

  _ActionsContainer.prototype._registryGet = function(arg1, arg2, arg3) {
    return this._registry_get(arg1, arg2, arg3);
  };

  _ActionsContainer.prototype.set_defaults = function(options) {
    var _i, _len, _ref, _results;
    _.extend(this._defaults, options);
    _ref = this._actions;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      action = _ref[_i];
      if (action.dest in options) {
        _results.push(action["default"] = options[action.dest]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _ActionsContainer.prototype.setDefaults = function(options) {
    return this.set_defaults(options);
  };

  _ActionsContainer.prototype.get_default = function(dest) {
    var _i, _len, _ref, _ref1;
    _ref = this._actions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      action = _ref[_i];
      if (action.dest === dest && action.defaultValue !== null) {
        return action.defaultValue;
      }
    }
    return (_ref1 = this._defaults[dest]) != null ? _ref1 : null;
  };

  _ActionsContainer.prototype.getDefault = function(dest) {
    return this.get_default(dest);
  };

  _ActionsContainer.prototype.add_argument = function() {
    var action_class, args, chars, dest, options, type_func, _i, _ref;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), options = arguments[_i++];
    "add_argument(dest, ..., name=value, ...)\nadd_argument(option_string, option_string, ..., name=value, ...)";
    if (_.isString(options)) {
      args.push(options);
      options = {};
    }
    if (options == null) {
      options = {};
    }
    chars = this.prefix_chars;
    if (args.length === 0 || (args.length === 1 && (_ref = args[0][0], __indexOf.call(chars, _ref) < 0))) {
      if (args.length > 0 && 'dest' in options) {
        throw new Error('dest supplied twice for positional argument');
      }
      options = this._get_positional_options(args, options);
    } else {
      options = this._get_optional_options(args, options);
    }
    if (!('defaultValue' in options)) {
      dest = options.dest;
      if (dest in this._defaults) {
        options.defaultValue = this._defaults[dest];
      } else if (this.argument_default !== null) {
        options.defaultValue = this.argument_default;
      } else {
        options.defaultValue = null;
      }
    }
    action_class = this._pop_action_class(options);
    if (!_.isFunction(action_class)) {
      throw new Error("unknown action '" + action_class + "'");
    }
    action = new action_class(options);
    type_func = this._registry_get('type', action.type, action.type);
    if (!_.isFunction(type_func)) {
      throw new Error("" + type_func + " is not callable");
    }
    if (this._check_argument != null) {
      this._check_argument(action);
    }
    /*
    # raise an error if the metavar does not match the type
    # replaced by above check_argument
    if @_get_formatter?
        try
            @_get_formatter()._format_args(action, null)
        catch error
            throw new Error("length of metavar tuple does not match nargs")
    */

    return this._add_action(action);
  };

  _ActionsContainer.prototype.addArgument = function(args, options) {
    return this.add_argument.apply(this, __slice.call(args).concat([options]));
  };

  _ActionsContainer.prototype.add_argument_group = function(options) {
    var group;
    group = new _ArgumentGroup(this, options);
    this._action_groups.push(group);
    return group;
  };

  _ActionsContainer.prototype.addArgumentGroup = function(options) {
    return this.add_argument_group(options);
  };

  _ActionsContainer.prototype.add_mutually_exclusive_group = function(options) {
    var group;
    if (options == null) {
      options = {};
    }
    group = new _MutuallyExclusiveGroup(this, options);
    this._mutually_exclusive_groups.push(group);
    return group;
  };

  _ActionsContainer.prototype.addMutuallyExclusiveGroup = function(options) {
    return this.add_mutually_exclusive_group(options);
  };

  _ActionsContainer.prototype._add_action = function(action) {
    var option_string, _i, _j, _len, _len1, _ref, _ref1;
    this._check_conflict(action);
    this._actions.push(action);
    action.container = this;
    _ref = action.option_strings;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      option_string = _ref[_i];
      this._option_string_actions[option_string] = action;
    }
    _ref1 = action.option_strings;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      option_string = _ref1[_j];
      if (option_string.match(this._negative_number_matcher)) {
        if (!_.any(this._hasNegativeNumberOptionals)) {
          this._hasNegativeNumberOptionals.push(true);
        }
      }
    }
    return action;
  };

  _ActionsContainer.prototype._remove_action = function(action) {
    var i;
    i = this._actions.indexOf(action);
    if (i >= 0) {
      return this._actions.splice(i, 1);
    }
  };

  _ActionsContainer.prototype._add_container_actions = function(container) {
    var actionHash, ctr, group, group_map, msg, mutex_group, title_group_map, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;
    title_group_map = {};
    _ref = this._action_groups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      if (group.title in title_group_map) {
        msg = "cannot merge actions - two groups are named " + group.title;
        throw new Error(msg);
      }
      title_group_map[group.title] = group;
    }
    group_map = {};
    actionHash = function(action) {
      return action.getName();
    };
    _ref1 = container._action_groups;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      if (!(group.title in title_group_map)) {
        title_group_map[group.title] = this.add_argument_group({
          title: group.title,
          description: group.description,
          conflict_handler: group.conflict_handler
        });
      }
      _ref2 = group._group_actions;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        action = _ref2[_k];
        group_map[actionHash(action)] = title_group_map[group.title];
      }
    }
    _ref3 = container._mutually_exclusive_groups;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      group = _ref3[_l];
      mutex_group = this.add_mutually_exclusive_group({
        required: group.required
      });
      _ref4 = group._group_actions;
      for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
        action = _ref4[_m];
        group_map[actionHash(action)] = mutex_group;
      }
    }
    _ref5 = container._actions;
    _results = [];
    for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
      action = _ref5[_n];
      ctr = (_ref6 = group_map[action.getName()]) != null ? _ref6 : this;
      _results.push(ctr._add_action(action));
    }
    return _results;
  };

  _ActionsContainer.prototype._get_positional_options = function(dest, options) {
    var msg, result, _ref;
    if ('required' in options) {
      msg = "'required' is an invalid argument for positionals";
      throw new TypeError(msg);
    }
    if (_.isArray(dest)) {
      if (dest.length === 0) {
        dest = null;
      } else {
        dest = dest[0];
      }
    }
    /*
    if options.get('nargs') not in [$$.OPTIONAL, $$.ZERO_OR_MORE]
        options.required = True
    if options.get('nargs') == $$.ZERO_OR_MORE and 'defaultValue' not of options
        options.required = True
    */

    if ((_ref = options.nargs) !== $$.OPTIONAL && _ref !== $$.ZERO_OR_MORE) {
      options.required = true;
    } else if (options.nargs === $$.ZERO_OR_MORE && (options.defaultValue == null)) {
      options.required = true;
    } else {
      options.required = false;
    }
    result = _.clone(options);
    if (dest != null) {
      result.dest = dest;
    }
    result.option_strings = [];
    return result;
  };

  _ActionsContainer.prototype._get_optional_options = function(args, options) {
    var dest, dest_option_string, firstchar, long_option_strings, msg, option_string, option_strings, result, secondchar, _i, _len;
    option_strings = [];
    long_option_strings = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      option_string = args[_i];
      firstchar = option_string[0];
      secondchar = option_string[1];
      if (__indexOf.call(this.prefix_chars, firstchar) < 0) {
        msg = ("invalid option string " + option_string + ": ") + ("must start with a character " + this.prefix_chars);
        throw new Error(msg);
      }
      option_strings.push(option_string);
      if (__indexOf.call(this.prefix_chars, firstchar) >= 0) {
        if (option_string.length > 1) {
          if (__indexOf.call(this.prefix_chars, secondchar) >= 0) {
            long_option_strings.push(option_string);
          }
        }
      }
    }
    if (options.dest != null) {
      dest = options.dest;
      delete options.dest;
    } else {
      dest = null;
    }
    if (dest === null) {
      if (long_option_strings.length > 0) {
        dest_option_string = long_option_strings[0];
      } else {
        dest_option_string = option_strings[0];
      }
      dest = _.str.lstrip(dest_option_string, this.prefix_chars);
      if (!dest) {
        msg = "dest= is required for options like " + option_string;
        throw new Error(msg);
      }
      dest = dest.replace('-', '_');
    }
    result = _.clone(options);
    result.dest = dest;
    result.option_strings = option_strings;
    return result;
  };

  _ActionsContainer.prototype._pop_action_class = function(options, defaultValue) {
    if (defaultValue == null) {
      defaultValue = null;
    }
    if (options.action != null) {
      action = options.action;
      delete options.action;
    } else {
      action = defaultValue;
    }
    return this._registry_get('action', action, action);
  };

  _ActionsContainer.prototype._get_handler = function() {
    var func, handler_func_name, msg;
    handler_func_name = "_handle_conflict_" + this.conflict_handler;
    func = this[handler_func_name];
    if (func != null) {
      return func;
    } else {
      msg = "invalid conflict resolution value: " + this.conflict_handler;
      throw new Error(msg);
    }
  };

  _ActionsContainer.prototype._check_conflict = function(action) {
    var confl_optional, confl_optionals, conflict_handler, option_string, _i, _len, _ref;
    confl_optionals = [];
    _ref = action.option_strings;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      option_string = _ref[_i];
      if (option_string in this._option_string_actions) {
        confl_optional = this._option_string_actions[option_string];
        confl_optionals.push([option_string, confl_optional]);
      }
    }
    if (confl_optionals.length > 0) {
      conflict_handler = this._get_handler();
      return conflict_handler(action, confl_optionals);
    }
  };

  _ActionsContainer.prototype._handle_conflict_error = function(action, conflicting_actions) {
    var conflict_string, message, tpl;
    conflict_string = ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = conflicting_actions.length; _i < _len; _i++) {
        tpl = conflicting_actions[_i];
        _results.push(tpl[0]);
      }
      return _results;
    })()).join(', ');
    message = "Conflicting option string(s): " + conflict_string;
    throw new ArgumentError(action, message);
  };

  _ActionsContainer.prototype._handle_conflict_resolve = function(action, conflicting_actions) {
    var i, option_string, _i, _len, _ref, _results;
    _results = [];
    for (_i = 0, _len = conflicting_actions.length; _i < _len; _i++) {
      _ref = conflicting_actions[_i], option_string = _ref[0], action = _ref[1];
      i = action.option_strings.indexOf(option_string);
      if (i >= 0) {
        action.option_strings.splice(i, 1);
      }
      delete this._option_string_actions[option_string];
      if (action.option_strings.length === 0) {
        _results.push(action.container._remove_action(action));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return _ActionsContainer;

})();

_ArgumentGroup = (function(_super) {

  __extends(_ArgumentGroup, _super);

  function _ArgumentGroup(container, options) {
    var _ref, _ref1, _ref2;
    if (options == null) {
      options = {};
    }
    options.prefix_chars = (_ref = options.prefixChars) != null ? _ref : container.prefix_chars;
    options.argument_default = (_ref1 = options.argument_default) != null ? _ref1 : container.argument_default;
    options.conflict_handler = (_ref2 = options.conflict_handler) != null ? _ref2 : container.conflict_handler;
    _ArgumentGroup.__super__.constructor.call(this, options);
    this.title = options.title;
    this._group_actions = [];
    this._registries = container._registries;
    this._actions = container._actions;
    this._option_string_actions = container._option_string_actions;
    this._defaults = container._defaults;
    this._hasNegativeNumberOptionals = container._hasNegativeNumberOptionals;
    this._mutually_exclusive_groups = container._mutually_exclusive_groups;
    this._check_argument = container._check_argument;
    this._container = container;
  }

  _ArgumentGroup.prototype._add_action = function(action) {
    action = _ArgumentGroup.__super__._add_action.call(this, action);
    this._group_actions.push(action);
    return action;
  };

  _ArgumentGroup.prototype._remove_action = function(action) {
    var i;
    _ArgumentGroup.__super__._remove_action.call(this, action);
    i = this._group_actions.indexOf(action);
    if (i >= 0) {
      return this._group_actions.splice(i, 1);
    }
  };

  return _ArgumentGroup;

})(_ActionsContainer);

_MutuallyExclusiveGroup = (function(_super) {

  __extends(_MutuallyExclusiveGroup, _super);

  function _MutuallyExclusiveGroup(container, options) {
    _MutuallyExclusiveGroup.__super__.constructor.call(this, container, options);
    this.required = options.required;
  }

  _MutuallyExclusiveGroup.prototype._add_action = function(action) {
    var msg;
    if (action.required) {
      msg = 'mutually exclusive arguments must be optional';
      throw new Error(msg);
    }
    action = this._container._add_action(action);
    this._group_actions.push(action);
    return action;
  };

  _MutuallyExclusiveGroup.prototype._remove_action = function(action) {
    this._container._remove_action(action);
    return this._group_actions.remove(action);
  };

  return _MutuallyExclusiveGroup;

})(_ArgumentGroup);

/*
 * class ArgumentParser
 *
 * Object for parsing command line strings into js objects.
 *
 * Inherited from [[ActionContainer]]
*/


_.zipShortest = function() {
  var i, length, results, _i;
  length = _.min(_.pluck(arguments, 'length'));
  results = new Array(length);
  for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
    results[i] = _.pluck(arguments, String(i));
  }
  return results;
};

Namespace = (function() {

  function Namespace() {}

  Namespace.prototype.isset = function(key) {
    return this[key] != null;
  };

  Namespace.prototype.get = function(key, defaultValue) {
    var _ref;
    return (_ref = this[key]) != null ? _ref : defaultValue;
  };

  Namespace.prototype.set = function(key, value) {
    return this[key] = value;
  };

  Namespace.prototype.repr = function() {
    return 'Namespace' + util.inspect(this);
  };

  return Namespace;

})();

ArgumentParser = (function(_super) {

  __extends(ArgumentParser, _super);

  function ArgumentParser(options) {
    var acoptions, defaultKey, default_prefix, parent, _i, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
      _this = this;
    if (options == null) {
      options = {};
    }
    this._match_arguments_partial = function(actions, arg_strings_pattern) {
      return ArgumentParser.prototype._match_arguments_partial.apply(_this, arguments);
    };
    this._match_argument = function(action, arg_strings_pattern) {
      return ArgumentParser.prototype._match_argument.apply(_this, arguments);
    };
    this._read_args_from_files2 = function(arg_strings) {
      return ArgumentParser.prototype._read_args_from_files2.apply(_this, arguments);
    };
    this._read_args_from_files1 = function(arg_strings) {
      return ArgumentParser.prototype._read_args_from_files1.apply(_this, arguments);
    };
    this._check_argument = function(action) {
      return ArgumentParser.prototype._check_argument.apply(_this, arguments);
    };
    this.prog = (_ref = options.prog) != null ? _ref : path.basename(process.argv[1]);
    this.usage = (_ref1 = options.usage) != null ? _ref1 : null;
    this.epilog = (_ref2 = options.epilog) != null ? _ref2 : null;
    this.parents = (_ref3 = options.parents) != null ? _ref3 : [];
    this.formatter_class = (_ref4 = (_ref5 = options.formatter_class) != null ? _ref5 : options.formatterClass) != null ? _ref4 : HelpFormatter;
    this.fromfile_prefix_chars = (_ref6 = (_ref7 = options.fromfile_prefix_chars) != null ? _ref7 : options.fromfilePrefixChars) != null ? _ref6 : null;
    this.add_help = (_ref8 = (_ref9 = options.addHelp) != null ? _ref9 : options.add_help) != null ? _ref8 : true;
    this.debug = (_ref10 = options.debug) != null ? _ref10 : false;
    this.description = (_ref11 = options.description) != null ? _ref11 : null;
    this.prefix_chars = (_ref12 = (_ref13 = options.prefixChars) != null ? _ref13 : options.prefix_chars) != null ? _ref12 : '-';
    this.argument_default = (_ref14 = (_ref15 = options.argumentDefault) != null ? _ref15 : options.argument_default) != null ? _ref14 : null;
    this.conflict_handler = (_ref16 = (_ref17 = options.conflict_handler) != null ? _ref17 : options.conflictHandler) != null ? _ref16 : 'error';
    this.args_default_to_positional = (_ref18 = options.args_default_to_positional) != null ? _ref18 : false;
    acoptions = {
      description: this.description,
      prefixChars: this.prefix_chars,
      argument_default: this.argument_default,
      conflict_handler: this.conflict_handler
    };
    _ActionsContainer.call(this, acoptions);
    this._positionals = this.add_argument_group({
      title: 'Positional arguments'
    });
    this._optionals = this.add_argument_group({
      title: 'Optional arguments'
    });
    this._subparsers = null;
    this.register('type', null, function(o) {
      return o;
    });
    this.register('type', 'auto', function(o) {
      return o;
    });
    this.register('type', 'int', function(x) {
      var result;
      result = parseInt(x, 10);
      if (isNaN(result)) {
        throw new TypeError("" + x + " is not a valid integer.");
      }
      return result;
    });
    this.register('type', 'float', function(x) {
      var result;
      result = parseFloat(x, 10);
      if (isNaN(result)) {
        throw new TypeError("" + x + " is not a valid float.");
      }
      return result;
    });
    this.register('type', 'string', function(x) {
      return '' + x;
    });
    default_prefix = __indexOf.call(this.prefix_chars, '-') >= 0 ? '-' : this.prefix_chars[0];
    if (this.add_help) {
      this.addArgument([default_prefix + 'h', default_prefix + default_prefix + 'help'], {
        action: 'help',
        defaultValue: $$.SUPPRESS,
        help: 'Show this help message and exit'
      });
    }
    if (this.version) {
      this.addArgument([default_prefix + 'v', default_prefix + default_prefix + 'version'], {
        action: 'version',
        "default": $$.SUPPRESS,
        version: this.version,
        help: "show program's version number and exit"
      });
    }
    _ref19 = this.parents;
    for (_i = 0, _len = _ref19.length; _i < _len; _i++) {
      parent = _ref19[_i];
      this._add_container_actions(parent);
      if (parent._defaults != null) {
        for (defaultKey in parent._defaults) {
          if (parent._defaults[defaultKey] != null) {
            this._defaults[defaultKey] = parent._defaults[defaultKey];
          }
        }
      }
    }
    this;
  }

  ArgumentParser.prototype.repr = function() {
    var names;
    names = ['prog', 'usage', 'description', 'formatter_class', 'conflict_handler', 'add_help', 'debug'];
    return __repr__(this, names);
  };

  ArgumentParser.prototype.toString = ArgumentParser.prototype.repr;

  ArgumentParser.prototype.print_actions = function() {
    var a;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this._actions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        _results.push(a + "");
      }
      return _results;
    }).call(this)).join('\n');
  };

  ArgumentParser.prototype.add_subparsers = function(options) {
    var ParsersClass, description, formatter, groups, positionals, title, _ref, _ref1, _ref2;
    if (options == null) {
      options = {};
    }
    if (this._subparsers != null) {
      this.error('cannot have multiple subparser arguments');
    }
    options.defaultValue = null;
    options.debug = this.debug;
    options.option_strings = [];
    options.parserClass = options.parserClass || ArgumentParser;
    if ((options.title != null) || (options.description != null)) {
      title = (_ref = options.title) != null ? _ref : 'subcommands';
      description = (_ref1 = options.description) != null ? _ref1 : null;
      delete options.title;
      delete options.description;
      this._subparsers = this.add_argument_group({
        title: title,
        description: description
      });
    } else {
      this._subparsers = this._positionals;
    }
    if (options.prog == null) {
      formatter = this._get_formatter();
      positionals = this._get_positional_actions();
      groups = (_ref2 = this._mutuallyExclusiveGroups) != null ? _ref2 : this._mutually_exclusive_groups;
      formatter.addUsage(this.usage, positionals, groups, '');
      options.prog = _.str.strip(formatter.formatHelp());
    }
    if (this._popActionClass != null) {
      ParsersClass = this._popActionClass(options, 'parsers');
    } else {
      ParsersClass = this._pop_action_class(options, 'parsers');
    }
    action = new ParsersClass(options);
    if (this._subparsers._add_action != null) {
      this._subparsers._add_action(action);
    } else {
      this._subparsers._add_action(action);
    }
    return action;
  };

  ArgumentParser.prototype._add_action = function(action) {
    if (action.isOptional()) {
      assert(action.option_strings);
      this._optionals._add_action(action);
    } else {
      this._positionals._add_action(action);
    }
    return action;
  };

  ArgumentParser.prototype._get_optional_actions = function() {
    return (function() {
      var _i, _len, _ref, _results;
      _ref = this._actions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        action = _ref[_i];
        if (action.isOptional()) {
          _results.push(action);
        }
      }
      return _results;
    }).call(this);
  };

  ArgumentParser.prototype._get_positional_actions = function() {
    return (function() {
      var _i, _len, _ref, _results;
      _ref = this._actions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        action = _ref[_i];
        if (action.isPositional()) {
          _results.push(action);
        }
      }
      return _results;
    }).call(this);
  };

  ArgumentParser.prototype._check_argument = function(action) {
    try {
      return this._get_formatter()._format_args(action, null);
    } catch (error) {
      throw new ArgumentError(action, error.message);
    }
  };

  ArgumentParser.prototype.parse_args = function(args, namespace) {
    var argv, msg, _ref;
    if (args == null) {
      args = null;
    }
    if (namespace == null) {
      namespace = null;
    }
    _ref = this.parse_known_args(args, namespace), args = _ref[0], argv = _ref[1];
    if (argv.length > 0) {
      msg = "unrecognized arguments: " + (argv.join(' '));
      this.error(msg);
    }
    return args;
  };

  ArgumentParser.prototype.parse_known_args = function(args, namespace) {
    var argv, dest, _default, _i, _len, _ref, _ref1;
    if (args == null) {
      args = null;
    }
    if (namespace == null) {
      namespace = null;
    }
    args = args || process.argv.slice(2);
    namespace = namespace != null ? namespace : new Namespace();
    _ref = this._actions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      action = _ref[_i];
      if (action.dest !== $$.SUPPRESS) {
        if (!namespace.isset(action.dest)) {
          if (action.defaultValue !== $$.SUPPRESS) {
            _default = action.defaultValue;
            namespace.set(action.dest, _default);
          }
        }
      }
    }
    for (dest in this._defaults) {
      if (!namespace.isset(dest)) {
        namespace.set(dest, this._defaults[dest]);
      }
    }
    try {
      _ref1 = this._parse_known_args(args, namespace), namespace = _ref1[0], args = _ref1[1];
      if (namespace.isset($$._UNRECOGNIZED_ARGS_ATTR)) {
        args.push(namespace.get($$._UNRECOGNIZED_ARGS_ATTR));
        delete namespace[$$._UNRECOGNIZED_ARGS_ATTR];
      }
      return [namespace, args];
    } catch (error) {
      if (error instanceof ArgumentError) {
        this.error(error);
      } else {
        throw error;
      }
    }
    argv = [];
    return [args, argv];
  };

  ArgumentParser.prototype._parse_known_args = function(arg_strings, namespace) {
    var actionConflicts, actionHash, action_used, arg_string, arg_string_pattern, arg_string_pattern_parts, conflicts, consume_optional, consume_positionals, extras, foo, gactions, group, group_actions, i, index_keys, key, max_option_string_index, msg, mutex_action, mutex_group, mxgroups, names, next_option_string_index, option_string_indices, option_tuple, pattern, positionals, positionals_end_index, required_actions, seen_actions, seen_non_default_actions, start_index, stop_index, strings, take_action, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
      _this = this;
    if (this.fromfile_prefix_chars != null) {
      arg_strings = this._read_args_from_files1(arg_strings);
    }
    actionConflicts = {};
    actionHash = function(action) {
      return action.getName();
    };
    mxgroups = (_ref = this._mutuallyExclusiveGroups) != null ? _ref : this._mutually_exclusive_groups;
    for (_i = 0, _len = mxgroups.length; _i < _len; _i++) {
      mutex_group = mxgroups[_i];
      group_actions = (_ref1 = mutex_group._groupActions) != null ? _ref1 : mutex_group._group_actions;
      for (i = _j = 0, _len1 = group_actions.length; _j < _len1; i = ++_j) {
        mutex_action = group_actions[i];
        key = actionHash(mutex_action);
        if (actionConflicts[key] == null) {
          actionConflicts[key] = [];
        }
        conflicts = actionConflicts[key];
        conflicts.push.apply(conflicts, group_actions.slice(0, i));
        conflicts.push.apply(conflicts, group_actions.slice(i + 1));
      }
    }
    option_string_indices = {};
    arg_string_pattern_parts = [];
    for (i = _k = 0, _len2 = arg_strings.length; _k < _len2; i = ++_k) {
      arg_string = arg_strings[i];
      if (arg_string === '--') {
        arg_string_pattern_parts.push('-');
        _ref2 = arg_strings.slice(i + 1);
        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
          arg_string = _ref2[_l];
          arg_string_pattern_parts.push('A');
        }
        break;
      } else {
        option_tuple = this._parse_optional(arg_string);
        if (option_tuple === null) {
          pattern = 'A';
        } else {
          option_string_indices[i] = option_tuple;
          pattern = 'O';
        }
        arg_string_pattern_parts.push(pattern);
      }
    }
    arg_string_pattern = arg_string_pattern_parts.join('');
    DEBUG('pattern:', arg_string_pattern, _.keys(option_string_indices));
    assert(((function() {
      var _len4, _m, _results;
      _results = [];
      for (_m = 0, _len4 = arg_string_pattern.length; _m < _len4; _m++) {
        x = arg_string_pattern[_m];
        if (x === '-') {
          _results.push(x);
        }
      }
      return _results;
    })()).length < 2);
    seen_actions = [];
    seen_non_default_actions = [];
    take_action = function(action, argument_strings, option_string) {
      var actionConflict, argument_values, msg, _len4, _m, _ref3;
      if (option_string == null) {
        option_string = null;
      }
      seen_actions.push(action);
      argument_values = _this._get_values(action, argument_strings);
      if (argument_values !== action.defaultValue) {
        seen_non_default_actions.push(action);
        key = actionHash(action);
        if (actionConflicts[key] != null) {
          _ref3 = actionConflicts[key];
          for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
            actionConflict = _ref3[_m];
            if (__indexOf.call(seen_non_default_actions, actionConflict) >= 0) {
              msg = "not allowed with argument " + (actionConflict.getName());
              throw new ArgumentError(action, msg);
            }
          }
        }
      }
      if (argument_values !== $$.SUPPRESS) {
        return action.call(_this, namespace, argument_values, option_string);
      }
    };
    consume_optional = function(start_index) {
      var action_tuples, arg_count, args, chars, explicit_arg, match_argument, msg, new_explicit_arg, option_string, optionals_map, selected_patterns, start, stop, tuple, _len4, _m, _ref3;
      option_tuple = option_string_indices[start_index];
      action = option_tuple[0], option_string = option_tuple[1], explicit_arg = option_tuple[2];
      match_argument = _this._match_argument;
      action_tuples = [];
      while (true) {
        if (action === null) {
          extras.push(arg_strings[start_index]);
          return start_index + 1;
        }
        if (explicit_arg != null) {
          arg_count = match_argument(action, 'A');
          chars = _this.prefix_chars;
          if (arg_count === 0 && (_ref3 = option_string[1], __indexOf.call(chars, _ref3) < 0)) {
            action_tuples.push([action, [], option_string]);
            option_string = option_string[0] + explicit_arg[0];
            new_explicit_arg = explicit_arg.slice(1) || null;
            optionals_map = _this._option_string_actions;
            if (optionals_map[option_string] != null) {
              action = optionals_map[option_string];
              explicit_arg = new_explicit_arg;
            } else {
              if (false) {
                msg = "ignored explicit argument " + explicit_arg;
                throw new ArgumentError(action, msg);
              } else {
                extras.push(option_string);
                explicit_arg = new_explicit_arg;
              }
            }
          } else if (arg_count === 1) {
            stop = start_index + 1;
            args = [explicit_arg];
            action_tuples.push([action, args, option_string]);
            break;
          } else {
            msg = "ignored explicit argument " + explicit_arg;
            _this.error(action.getName() + ': ' + msg);
          }
        } else {
          start = start_index + 1;
          selected_patterns = arg_string_pattern.slice(start);
          arg_count = match_argument(action, selected_patterns);
          stop = start + arg_count;
          args = arg_strings.slice(start, stop);
          action_tuples.push([action, args, option_string]);
          break;
        }
      }
      for (_m = 0, _len4 = action_tuples.length; _m < _len4; _m++) {
        tuple = action_tuples[_m];
        take_action.apply(null, tuple);
      }
      return stop;
    };
    positionals = this._get_positional_actions();
    consume_positionals = function(start_index) {
      var arg_count, arg_counts, args, ii, match_partial, pats, selected_pattern, _len4, _m, _ref3, _ref4, _ref5, _ref6, _ref7;
      match_partial = _this._match_arguments_partial;
      selected_pattern = arg_string_pattern.slice(start_index);
      DEBUG('cp', selected_pattern);
      arg_counts = match_partial(positionals, selected_pattern);
      if (__indexOf.call(arg_string_pattern.slice(start_index), 'O') >= 0) {
        while (arg_counts.length > 1 && arg_counts[arg_counts.length - 1] === 0) {
          console.log('mixed o&p:', arg_counts, arg_string_pattern);
          arg_counts.pop();
        }
      }
      DEBUG('arg count:', arg_counts);
      _ref3 = _.zipShortest(positionals, arg_counts);
      for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
        _ref4 = _ref3[_m], action = _ref4[0], arg_count = _ref4[1];
        args = arg_strings.slice(start_index, start_index + arg_count);
        if ((_ref5 = action.nargs) !== $$.PARSER && _ref5 !== $$.REMAINDER) {
          pats = arg_string_pattern.slice(start_index, start_index + arg_count);
          DEBUG('take action:', action.dest, args, pats);
          ii = pats.indexOf('-');
          if (ii > -1) {
            assert(args[ii] === '--');
            [].splice.apply(args, [ii, ii - ii + 1].concat(_ref6 = [])), _ref6;
            DEBUG('take action:', action.dest, args);
          }
        }
        start_index += arg_count;
        take_action(action, args);
      }
      [].splice.apply(positionals, [0, 9e9].concat(_ref7 = positionals.slice(arg_counts.length))), _ref7;
      return start_index;
    };
    extras = [];
    start_index = 0;
    index_keys = (function() {
      var _len4, _m, _ref3, _results;
      _ref3 = _.keys(option_string_indices);
      _results = [];
      for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
        x = _ref3[_m];
        _results.push(+x);
      }
      return _results;
    })();
    if (index_keys.length > 0) {
      max_option_string_index = Math.max.apply(Math, index_keys);
    } else {
      max_option_string_index = -1;
    }
    foo = function(start_index) {
      var index, _len4, _m, _results;
      _results = [];
      for (_m = 0, _len4 = index_keys.length; _m < _len4; _m++) {
        index = index_keys[_m];
        if (index >= start_index) {
          _results.push(index);
        }
      }
      return _results;
    };
    while (start_index <= max_option_string_index) {
      next_option_string_index = Math.min.apply(Math, foo(start_index));
      if (start_index !== next_option_string_index) {
        positionals_end_index = consume_positionals(start_index);
        if (positionals_end_index > start_index) {
          start_index = positionals_end_index;
          continue;
        } else {
          start_index = positionals_end_index;
        }
      }
      if (__indexOf.call(index_keys, start_index) < 0) {
        strings = arg_strings.slice(start_index, next_option_string_index);
        extras.push.apply(extras, strings);
        start_index = next_option_string_index;
      }
      start_index = consume_optional(start_index);
    }
    stop_index = consume_positionals(start_index);
    extras.push.apply(extras, arg_strings.slice(stop_index));
    required_actions = [];
    _ref3 = this._actions;
    for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
      action = _ref3[_m];
      /*
      if action.required
          if action not in seen_actions
              @error("argument #{action.getName()} is required")
      */

      if (__indexOf.call(seen_actions, action) < 0) {
        if (action.required) {
          required_actions.push(action.getName());
        } else {
          if (_.isString(action.defaultValue) && (namespace[action.dest] != null) && action.defaultValue === namespace[action.dest]) {
            namespace[action.dest] = this._get_value(action, action.defaultValue);
          }
        }
      }
    }
    if (required_actions.length > 0) {
      required_actions = required_actions.join(',');
      msg = "the following argument(s) are required: " + required_actions;
      this.error(msg);
    }
    action_used = false;
    _ref5 = (_ref4 = this._mutuallyExclusiveGroups) != null ? _ref4 : this._mutually_exclusive_groups;
    for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
      group = _ref5[_n];
      if (group.required) {
        gactions = (_ref6 = group._groupActions) != null ? _ref6 : group._group_actions;
        for (_o = 0, _len6 = gactions.length; _o < _len6; _o++) {
          action = gactions[_o];
          if (__indexOf.call(seen_non_default_actions, action) >= 0) {
            action_used = true;
            break;
          }
        }
        if (!action_used) {
          names = (function() {
            var _len7, _p, _results;
            _results = [];
            for (_p = 0, _len7 = gactions.length; _p < _len7; _p++) {
              action = gactions[_p];
              if (action.help !== $$.SUPPRESS) {
                _results.push(action.getName());
              }
            }
            return _results;
          })();
          msg = "one of the arguments " + (names.join(' ')) + " is required";
          this.error(msg);
        }
      }
    }
    return [namespace, extras];
  };

  ArgumentParser.prototype._read_args_from_files = function(arg_strings) {
    var arg, arg_line, arg_string, argstrs, content, filename, firstchar, fs, new_arg_strings, _i, _j, _k, _len, _len1, _len2, _ref;
    fs = require('fs');
    new_arg_strings = [];
    for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
      arg_string = arg_strings[_i];
      firstchar = arg_string[0];
      if (__indexOf.call(this.fromfile_prefix_chars, firstchar) < 0) {
        new_arg_strings.push(arg_string);
      } else {
        try {
          argstrs = [];
          filename = arg_string.slice(1);
          content = fs.readFileSync(filename, 'utf8');
          content = content.trim().split('\n');
          for (_j = 0, _len1 = content.length; _j < _len1; _j++) {
            arg_line = content[_j];
            _ref = this.convert_arg_line_to_args(arg_line);
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              arg = _ref[_k];
              argstrs.push(arg);
            }
            argstrs = this._read_args_from_files(argstrs);
          }
          new_arg_strings.push.apply(new_arg_strings, argstrs);
        } catch (error) {
          this.error(error.message);
        }
      }
    }
    return new_arg_strings;
  };

  ArgumentParser.prototype._read_args_from_files1 = function(arg_strings) {
    /* expand arguments referencing files
    adding ,@ context to forEach takes care of binding problems
    */

    var convert_line, fs, new_arg_strings, prefix_chars, read_args;
    prefix_chars = this.fromfile_prefix_chars;
    convert_line = this.convert_arg_line_to_args;
    read_args = this._read_args_from_files;
    fs = require('fs');
    new_arg_strings = [];
    arg_strings.forEach(function(arg_string) {
      /* for regular arguments, just add them back into the list
      */

      var argstrs, content, filename;
      if (this.fromfile_prefix_chars.indexOf(arg_string[0]) < 0) {
        return new_arg_strings.push(arg_string);
        /* replace arguments referencing files with the file content
        */

      } else {
        try {
          argstrs = [];
          filename = arg_string.slice(1);
          content = fs.readFileSync(filename, 'utf8');
          content = content.trim().split('\n');
          content.forEach(function(arg_line) {
            this.convert_arg_line_to_args(arg_line).forEach(function(arg) {
              return argstrs.push(arg);
            });
            return argstrs = this._read_args_from_files1(argstrs);
          }, this);
          return new_arg_strings.push.apply(new_arg_strings, argstrs);
        } catch (error) {
          return this.error(error.message);
        }
      }
    }, this);
    return new_arg_strings;
  };

  ArgumentParser.prototype._read_args_from_files2 = function(arg_strings) {
    /* expand arguments referencing files
    try to use the async form of readfile;
    it doesnt wait for the read to finish
    */

    var convert_line, fs, new_arg_strings, prefix_chars, read_args,
      _this = this;
    prefix_chars = this.fromfile_prefix_chars;
    convert_line = this.convert_arg_line_to_args;
    read_args = this._read_args_from_files;
    fs = require('fs');
    new_arg_strings = [];
    arg_strings.forEach(function(arg_string) {
      /* for regular arguments, just add them back into the list
      */

      var argstrs, filename;
      if (_this.fromfile_prefix_chars.indexOf(arg_string[0]) < 0) {
        return new_arg_strings.push(arg_string);
        /* replace arguments referencing files with the file content
        */

      } else {
        try {
          argstrs = [];
          filename = arg_string.slice(1);
          return fs.readFile(filename, 'utf8', function(err, data) {
            if (err) {
              throw err;
            }
            data = data.trim().split('\n');
            content.forEach(function(arg_line) {
              this.convert_arg_line_to_args(arg_line).forEach(function(arg) {
                return argstrs.push(arg);
              });
              return argstrs = this._read_args_from_files2(argstrs);
            });
            return new_arg_strings.push.apply(new_arg_strings, argstrs);
          });
        } catch (error) {
          return _this.error(error.message);
        }
      }
    });
    return new_arg_strings;
  };

  ArgumentParser.prototype.convert_arg_line_to_args = function(arg_line) {
    return [arg_line];
  };

  ArgumentParser.prototype._match_argument = function(action, arg_strings_pattern) {
    var args_errors, matches, msg, nargs_pattern, _ref;
    nargs_pattern = this._get_nargs_pattern(action);
    nargs_pattern = '^' + nargs_pattern;
    matches = arg_strings_pattern.match(nargs_pattern);
    if (matches == null) {
      args_errors = {
        "null": 'expected one argument'
      };
      args_errors[$$.OPTIONAL] = 'expected at most one argument';
      args_errors[$$.ONE_OR_MORE] = 'expected at least one argument';
      msg = (_ref = args_errors[action.nargs]) != null ? _ref : "expected " + action.nargs + " argument(s)";
      throw new ArgumentError(action, msg);
    }
    return matches[1].length;
  };

  ArgumentParser.prototype._match_arguments_partial = function(actions, arg_strings_pattern) {
    var actions_slice, foo, i, m, pattern, result, strlength, _i, _ref;
    result = [];
    foo = this._get_nargs_pattern;
    strlength = function(string) {
      return string.length;
    };
    for (i = _i = _ref = actions.length; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
      actions_slice = actions.slice(0, i);
      pattern = actions_slice.map(foo).join('');
      m = arg_strings_pattern.match('^' + pattern);
      if (m != null) {
        result.push.apply(result, m.slice(1).map(strlength));
        break;
      }
    }
    return result;
  };

  ArgumentParser.prototype._parse_optional = function(arg_string) {
    var actions, explicit_arg, option_string, option_tuple, option_tuples, options, tup, _ref, _ref1;
    assert(this.prefix_chars != null);
    if (!arg_string) {
      return null;
    }
    if (!(_ref = arg_string[0], __indexOf.call(this.prefix_chars, _ref) >= 0)) {
      return null;
    }
    actions = this._option_string_actions;
    if (actions[arg_string] != null) {
      action = actions[arg_string];
      return [action, arg_string, null];
    }
    if (arg_string.length === 1) {
      return null;
    }
    if (__indexOf.call(arg_string, '=') >= 0) {
      _ref1 = arg_string.split('='), option_string = _ref1[0], explicit_arg = _ref1[1];
      if (actions[option_string] != null) {
        action = actions[option_string];
        return [action, option_string, explicit_arg];
      }
    }
    option_tuples = this._get_option_tuples(arg_string);
    if (option_tuples.length > 1) {
      options = (function() {
        var _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = option_tuples.length; _i < _len; _i++) {
          _ref2 = option_tuples[_i], action = _ref2[0], option_string = _ref2[1], explicit_arg = _ref2[2];
          _results.push(option_string);
        }
        return _results;
      })();
      options = options.join(', ');
      tup = [arg_string, options];
      this.error("ambiguous option: " + arg_string + " could match " + options);
    } else if (option_tuples.length === 1) {
      option_tuple = option_tuples[0];
      return option_tuple;
    }
    if (this.args_default_to_positional) {
      return null;
    }
    if (!_.any(this._hasNegativeNumberOptionals) && !isNaN(arg_string)) {
      return null;
    }
    if (__indexOf.call(arg_string, ' ') >= 0) {
      return null;
    }
    return [null, arg_string, null];
  };

  ArgumentParser.prototype._get_option_tuples = function(option_string) {
    var actions, chars, explicit_arg, option_prefix, result, short_explicit_arg, short_option_prefix, tup, _ref, _ref1, _ref2, _ref3, _ref4;
    result = [];
    chars = this.prefix_chars;
    if ((_ref = option_string[0], __indexOf.call(chars, _ref) >= 0) && (_ref1 = option_string[1], __indexOf.call(chars, _ref1) >= 0)) {
      if (__indexOf.call(option_string, '=') >= 0) {
        _ref2 = option_string.split('='), option_prefix = _ref2[0], explicit_arg = _ref2[1];
      } else {
        option_prefix = option_string;
        explicit_arg = null;
      }
      actions = this._option_string_actions;
      for (option_string in actions) {
        if (_.str.startsWith(option_string, option_prefix)) {
          action = actions[option_string];
          tup = [action, option_string, explicit_arg];
          result.push(tup);
        }
      }
    } else if ((_ref3 = option_string[0], __indexOf.call(chars, _ref3) >= 0) && (_ref4 = option_string[1], __indexOf.call(chars, _ref4) < 0)) {
      option_prefix = option_string;
      explicit_arg = null;
      short_option_prefix = option_string.slice(0, 2);
      short_explicit_arg = option_string.slice(2);
      actions = this._option_string_actions;
      for (option_string in actions) {
        if (option_string === short_option_prefix) {
          action = actions[option_string];
          tup = [action, option_string, short_explicit_arg];
          result.push(tup);
        } else if (_.str.startsWith(option_string, option_prefix)) {
          action = actions[option_string];
          tup = [action, option_string, explicit_arg];
          result.push(tup);
        }
      }
    } else {
      this.error("unexpected option string: " + option_string);
    }
    return result;
  };

  ArgumentParser.prototype._get_nargs_pattern = function(action) {
    var nargs, nargs_pattern;
    nargs = action.nargs;
    if (nargs === null) {
      nargs_pattern = '(-*A-*)';
    } else if (nargs === $$.OPTIONAL) {
      nargs_pattern = '(-*A?-*)';
    } else if (nargs === $$.ZERO_OR_MORE) {
      nargs_pattern = '(-*[A-]*)';
    } else if (nargs === $$.ONE_OR_MORE) {
      nargs_pattern = '(-*A[A-]*)';
    } else if (nargs === $$.REMAINDER) {
      nargs_pattern = '([-AO]*)';
    } else if (nargs === $$.PARSER) {
      nargs_pattern = '(-*A[-AO]*)';
    } else {
      nargs_pattern = "(-*" + (_.str.repeat('-*A', nargs)) + "-*)";
    }
    if (action.isOptional()) {
      nargs_pattern = nargs_pattern.replace(/-\*/g, '');
      nargs_pattern = nargs_pattern.replace(/-/g, '');
    }
    return nargs_pattern;
  };

  ArgumentParser.prototype._get_values = function(action, arg_strings) {
    var arg_string, ii, s, v, value, _i, _len, _ref, _ref1;
    if ((_ref = action.nargs) !== $$.PARSER && _ref !== $$.REMAINDER) {
      switch ('none') {
        case 'all':
          arg_strings = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
              s = arg_strings[_i];
              if (s !== '--') {
                _results.push(s);
              }
            }
            return _results;
          })();
          break;
        case 'first':
          ii = arg_strings.indexOf('--');
          if (ii >= 0) {
            console.log('WITH -- ', arg_strings, action.dest);
          }
          arg_strings = arg_strings.filter(function(s, i) {
            return i !== ii;
          });
          break;
        case 'none':
          break;
        default:
          '';
      }
    }
    if (arg_strings.length === 0 && action.nargs === $$.OPTIONAL) {
      if (action.isOptional()) {
        value = action.constant;
      } else {
        value = action.defaultValue;
      }
      if (_.isString(value)) {
        value = this._get_value(action, value);
        this._check_value(action, value);
      }
    } else if (arg_strings.length === 0 && action.nargs === $$.ZERO_OR_MORE && action.isPositional()) {
      if (action.defaultValue != null) {
        value = action.defaultValue;
      } else {
        value = arg_strings;
      }
      this._check_value(action, value);
    } else if (arg_strings.length === 1 && ((_ref1 = action.nargs) === null || _ref1 === $$.OPTIONAL)) {
      arg_string = arg_strings[0];
      value = this._get_value(action, arg_string);
      this._check_value(action, value);
    } else if (action.nargs === $$.REMAINDER) {
      value = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
          v = arg_strings[_i];
          _results.push(this._get_value(action, v));
        }
        return _results;
      }).call(this);
    } else if (action.nargs === $$.PARSER) {
      value = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
          v = arg_strings[_i];
          _results.push(this._get_value(action, v));
        }
        return _results;
      }).call(this);
      this._check_value(action, value[0]);
    } else {
      value = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
          v = arg_strings[_i];
          _results.push(this._get_value(action, v));
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        v = value[_i];
        this._check_value(action, v);
      }
    }
    return value;
  };

  ArgumentParser.prototype._get_value = function(action, arg_string) {
    var msg, name, result, type_func;
    type_func = this._registryGet('type', action.type, action.type);
    if (!_.isFunction(type_func)) {
      msg = "" + type_func + " is not callable";
      this.error(action.getName() + ': ' + msg);
    }
    try {
      result = type_func(arg_string);
    } catch (error) {
      if (_.isString(action.type)) {
        name = action.type;
      } else {
        name = action.type.name || action.type.displayName || '<function>';
      }
      if (error instanceof TypeError) {
        msg = "Invalid " + name + " value: " + arg_string;
        throw new ArgumentError(action, msg);
      } else if (error instanceof ArgumentTypeError) {
        throw new ArgumentError(action, error.message);
      } else {
        throw error;
      }
    }
    return result;
  };

  ArgumentParser.prototype._check_value = function(action, value) {
    var choices, msg;
    if (action.choices != null) {
      if (_.isString(action.choices)) {
        choices = action.choices;
        choices = choices.split(/\W+/);
        if (choices.length === 1) {
          choices = choices[0].split('');
        }
      } else if (_.isArray(action.choices)) {
        choices = action.choices;
      } else if (_.isObject(action.choices)) {
        choices = _.keys(action.choices);
      }
      if (__indexOf.call(choices, value) < 0) {
        msg = "invalid choice: " + value + " (choose from " + choices + ")";
        throw new ArgumentError(action, msg);
      }
    }
  };

  /*
  # argument_parser.js has more elaborate checkvalue
      ArgumentParser.prototype._checkValue = function (action, value) {
    // converted value must be one of the choices (if specified)
    var choices = action.choices;
    if (!!choices) {
      // choise for argument can by array or string
      if ((_.isString(choices) || _.isArray(choices)) &&
          choices.indexOf(value) !== -1) {
        return;
      }
      // choise for subparsers can by only hash
      if (_.isObject(choices) && !_.isArray(choices) && choices[value]) {
        return;
      }
  
      if (_.isString(choices)) {
        choices = choices.split('').join(', ');
      }
      else if (_.isArray(choices)) {
        choices =  choices.join(', ');
      }
      else {
        choices =  _.keys(choices).join(', ');
      }
      var message = _.str.sprintf(
        'Invalid choice: %(value)s (choose from [%(choices)s])',
        {value: value, choices: choices}
      );
      throw argumentError(action, message);
    }
  };
  */


  ArgumentParser.prototype.format_usage = function() {
    var formatter;
    formatter = this._get_formatter();
    formatter.addUsage(this.usage, this._actions, this._mutually_exclusive_groups);
    return formatter.formatHelp();
  };

  ArgumentParser.prototype.formatUsage = ArgumentParser.prototype.format_usage;

  ArgumentParser.prototype.format_help = function() {
    var actionGroup, formatter, _i, _len, _ref, _ref1, _ref2;
    formatter = this._get_formatter();
    formatter.addUsage(this.usage, this._actions, this._mutually_exclusive_groups);
    formatter.addText(this.description);
    _ref1 = (_ref = this._actionGroups) != null ? _ref : this._action_groups;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      actionGroup = _ref1[_i];
      formatter.startSection(actionGroup.title);
      formatter.addText(actionGroup.description);
      formatter.addArguments((_ref2 = actionGroup._groupActions) != null ? _ref2 : actionGroup._group_actions);
      formatter.endSection();
    }
    formatter.addText(this.epilog);
    return formatter.formatHelp();
  };

  ArgumentParser.prototype.formatHelp = ArgumentParser.prototype.format_help;

  ArgumentParser.prototype._get_formatter = function() {
    var FormatterClass, formatter;
    FormatterClass = this.formatter_class;
    return formatter = new FormatterClass({
      prog: this.prog
    });
  };

  ArgumentParser.prototype.printUsage = function() {
    return this._printMessage(this.format_usage());
  };

  ArgumentParser.prototype.print_usage = ArgumentParser.prototype.printUsage;

  ArgumentParser.prototype.printHelp = function() {
    return this._printMessage(this.format_help());
  };

  ArgumentParser.prototype.print_help = ArgumentParser.prototype.printHelp;

  ArgumentParser.prototype.error = function(err) {
    var message, msg;
    assert(this.debug != null, '@ error in @error');
    if (err instanceof Error) {
      if (this.debug) {
        throw err;
      }
      message = err.message;
    } else {
      message = err;
    }
    msg = "" + this.prog + ": error: " + message + $$.EOL;
    if (this.debug) {
      throw new Error(msg);
    }
    this.print_usage(process.stderr);
    return this.exit(2, msg);
  };

  ArgumentParser.prototype.exit = function(status, message) {
    if (message != null) {
      if (status === 0) {
        this._printMessage(message);
      } else {
        this._printMessage(message, process.stderr);
      }
    }
    if (this.debug) {
      throw new Error('Exit captured');
    } else {
      return process.exit(status);
    }
  };

  ArgumentParser.prototype._printMessage = function(message, stream) {
    if (stream == null) {
      stream = process.stdout;
    }
    if (message) {
      return stream.write('' + message);
    }
  };

  ArgumentParser.prototype.parseArgs = ArgumentParser.prototype.parse_args;

  ArgumentParser.prototype.parseKnownArgs = ArgumentParser.prototype.parse_known_args;

  ArgumentParser.prototype.addSubparsers = ArgumentParser.prototype.add_subparsers;

  if (ArgumentParser.prototype.add_argument == null) {
    ({
      add_argument: function() {
        var args, options, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), options = arguments[_i++];
        if (_.isString(options)) {
          args.push(options);
          options = {};
        }
        return this.addArgument(args, options);
      }
    });
  }

  return ArgumentParser;

})(_ActionsContainer);

/*
values py exports
__all__ = [
    'ArgumentParser',
    'ArgumentError',
    'ArgumentTypeError',
    'FileType',
    'HelpFormatter',
    'ArgumentDefaultsHelpFormatter',
    'RawDescriptionHelpFormatter',
    'RawTextHelpFormatter',
    'Namespace',
    'Action',
    'ONE_OR_MORE',
    'OPTIONAL',
    'PARSER',
    'REMAINDER',
    'SUPPRESS',
    'ZERO_OR_MORE',
]
*/


exports.ArgumentParser = ArgumentParser;

exports.ArgumentError = ArgumentError;

exports.ArgumentTypeError = ArgumentTypeError;

exports.FileType = FileType;

exports.fileType = fileType;

exports.HelpFormatter = HelpFormatter;

exports.ArgumentDefaultsHelpFormatter = ArgumentDefaultsHelpFormatter;

exports.RawDescriptionHelpFormatter = RawDescriptionHelpFormatter;

exports.RawTextHelpFormatter = RawTextHelpFormatter;

exports.Namespace = Namespace;

exports.Action = Action;

exports.Const = $$;

exports.newParser = function(options) {
  if (options == null) {
    options = {};
  }
  if (!options.debug) {
    options.debug = true;
  }
  return new ArgumentParser(options);
};

TEST = module.parent == null;

if ((module.parent == null) && ((process.argv[2] == null) || process.argv[2] !== 'nodebug')) {
  DEBUG = function() {
    var arg;
    arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    arg.unshift('==> ');
    return console.log.apply(console, arg);
  };
} else {
  DEBUG = function() {};
}

if (TEST) {
  (function() {
    var Nsp, args, c1, c2, childParser, parentParser, parser, parser2, subparsers, testparse;
    testparse = function(args) {
      console.log(args);
      if (_.isString(args)) {
        args = args.split(' ');
      }
      return console.log(((function() {
        try {
          return parser.parseArgs(args);
        } catch (error) {
          console.log('parseArgs error');
          return error + '';
        }
      })()));
    };
    if (0) {
      parser = new ArgumentParser();
      console.log(parser.format_help());
      parser.add_subparsers({});
      console.log('class:', console.log(ArgumentParser));
      console.log('proto');
      console.log(ArgumentParser.prototype);
      console.log(ArgumentParser.prototype.constructor.super_);
      console.log(ArgumentParser.prototype.constructor.__super__);
      console.log('=====================================');
      console.log(parser.formatHelp());
    }
    if (1) {
      parentParser = new ArgumentParser({
        add_help: false,
        description: 'parent'
      });
      parentParser.addArgument(['--x']);
      parentParser._defaults = {
        x: true
      };
      childParser = new ArgumentParser({
        description: 'child',
        parents: [parentParser]
      });
      childParser.addArgument(['--y']);
      childParser.addArgument(['xxx']);
      console.log(childParser.formatHelp());
      if (1) {
        console.log('parent:');
        console.log(parentParser + "");
        console.log('child:');
        console.log(childParser + "");
        console.log("child actions:\n", childParser.print_actions());
        console.log('child optional actions: ', (function() {
          var _i, _len, _ref, _results;
          _ref = childParser._optionals._group_actions;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            action = _ref[_i];
            _results.push(action.dest);
          }
          return _results;
        })());
        console.log('child positional actions: ', (function() {
          var _i, _len, _ref, _results;
          _ref = childParser._positionals._group_actions;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            action = _ref[_i];
            _results.push(action.dest);
          }
          return _results;
        })());
      }
      console.log('=====================================');
    }
    if (TEST && 1) {
      parser = new ArgumentParser({
        debug: true
      });
      subparsers = parser.addSubparsers({
        title: 'subcommands',
        dest: 'subcommand_name'
      });
      c1 = subparsers.addParser('c1', {
        aliases: ['co']
      });
      c1.addArgument(['-f', '--foo'], {});
      c1.addArgument(['-b', '--bar'], {});
      c2 = subparsers.addParser('c2', {});
      c2.addArgument(['--baz'], {});
      try {
        Nsp = new Namespace();
        Nsp.set('dummy', 'foobar');
        args = parser.parse_args('c1 --foo 5'.split(' '), Nsp);
        args = parser.parseArgs('c1 --foo 5'.split(' '), Nsp);
        console.log(args);
      } catch (error) {

      }
      parser.printHelp();
      testparse(['-h']);
      testparse(['c1', '-h']);
      testparse(['c2', '-h']);
      console.log('=====================================');
    }
    if (TEST && 1) {
      parser = new ArgumentParser({
        debug: true
      });
      parser.addArgument(['-1'], {
        dest: 'one'
      });
      parser.addArgument(['foo'], {
        nargs: '?'
      });
      testparse(['-h']);
      args = parser.parseArgs(['-1', 'X']);
      assert.equal(args.one, 'X');
      testparse(['FOO']);
      testparse(['-z']);
      testparse(['-2']);
      console.log('=====================================');
    }
    if (TEST && 0) {
      parser = new ArgumentParser({
        debug: true
      });
      parser.addArgument(['-x'], {
        type: 'float'
      });
      parser.addArgument(['-3'], {
        type: 'float',
        dest: 'y'
      });
      parser.addArgument(['z'], {
        nargs: '*'
      });
      args = parser.parse_args(['-2']);
      console.log(args);
    }
    if (TEST && 1) {
      console.log('=====================================');
      console.log('should be ok with scientific notation');
      parser = new ArgumentParser({
        debug: true
      });
      parser.addArgument(['--xlim'], {
        nargs: 2,
        type: 'float'
      });
      testparse(['--xlim', '-.002', '1e4']);
      testparse(['--xlim', '-0.002', '1e4']);
      testparse(['--xlim', '2.e3', '-1e4']);
      testparse(['--xlim', '-2.12e3', '-1e4']);
      testparse(['--xlim', '-0xff', '0x123']);
    }
    if (TEST && 1) {
      console.log('=====================================');
      console.log('option-like positionals not accepted');
      parser = new ArgumentParser({
        debug: true
      });
      parser.addArgument(['--onetwo'], {
        nargs: 2
      });
      testparse(['--onetwo', 'one', 'two']);
      testparse(['--onetwo', 'one', '-two']);
      testparse(['--onetwo', 'one', '--', '-two']);
      parser = new ArgumentParser({
        debug: true
      });
      parser.addArgument(['--one'], {
        nargs: 1
      });
      parser.addArgument(['two'], {
        nargs: '?'
      });
      testparse(['--one', 'one', 'two']);
      testparse(['--one', 'one', '--', '-two']);
      testparse(['--one=-one', '-two']);
      console.log('\nargs_default_to_positional:true');
      parser = new ArgumentParser({
        debug: true,
        args_default_to_positional: true
      });
      parser.addArgument(['--onetwo'], {
        nargs: 2
      });
      testparse(['--onetwo', 'one', 'two']);
      testparse(['--onetwo', 'one', '-two']);
      testparse(['--onetwo', 'one', '--', 'two']);
      parser = new ArgumentParser({
        debug: true,
        args_default_to_positional: true
      });
      parser.addArgument(['--one'], {
        nargs: 1
      });
      parser.addArgument(['two'], {
        nargs: '?'
      });
      testparse(['--one', 'one', 'two']);
      testparse(['--one', 'one', '--', '-two']);
      testparse(['--one=-one', '-two']);
      console.log(parser + "\n");
      console.log(parser.print_actions());
    }
    if (TEST && 1) {
      console.log('=====================================');
      console.log('test --');
      parser = exports.newParser();
      parser.add_argument('foo');
      parser.add_argument('bar', {
        nargs: '*'
      });
      testparse('1 2 3 4');
      testparse('-- 1 2 3 4');
      testparse('1 -- 2 3 4');
      testparse('1 2 -- 3 4');
      testparse('-- 1 2 -- 3 4');
      testparse('1 -- -- 2 3 4');
      testparse('-- -- 1 -- 2 -- 3 4');
      parser = exports.newParser();
      parser.addArgument(['-x'], {
        nargs: '*'
      });
      parser.addArgument(['y'], {
        nargs: '*'
      });
      args = parser.parseArgs([]);
      assert.deepEqual(args, {
        y: [],
        x: null
      });
      args = parser.parseArgs(['-x']);
      assert.deepEqual(args, {
        y: [],
        x: []
      });
      args = parser.parseArgs(['-x', 'a']);
      assert.deepEqual(args, {
        y: [],
        x: ['a']
      });
      args = parser.parseArgs(['-x', 'a', '--', 'b']);
      assert.deepEqual(args, {
        y: ['b'],
        x: ['a']
      });
    }
    if (TEST && 1) {
      console.log('=====================================');
      console.log('TestAddSubparsers');
      parser = exports.newParser();
      parser.add_argument('--foo', {
        action: 'store_true',
        help: 'foo help'
      });
      parser.add_argument('bar', {
        type: 'float',
        help: 'bar help'
      });
      subparsers = parser.add_subparsers({
        title: 'commands',
        help: 'command help'
      });
      parser2 = subparsers.add_parser('2');
      parser2.add_argument('-y', {
        choices: '123',
        help: 'y help'
      });
      parser2.add_argument('z', {
        nargs: '*',
        help: 'z help',
        type: 'float'
      });
      testparse('0.25 --foo 2 -y 2 3e3 -1e1');
      return testparse('0.25 --foo 2 -y 2 3e3 -- -1e1');
    }
  })();
}
