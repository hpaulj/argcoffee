// Generated by CoffeeScript 1.6.1
var $$, Action, ArgumentError, DEBUG, Namespace, action, assert, getattr, hasattr, namespace, parser, path, setattr, util, _, _AppendAction, _AppendConstAction, _CountAction, _HelpAction, _StoreAction, _StoreConstAction, _StoreFalseAction, _StoreTrueAction, _SubParsersAction, _VersionAction, _ensure_value,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  _this = this;

if (module.parent == null) {
  DEBUG = function() {
    var arg;
    arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    arg.unshift('A===> ');
    return console.log.apply(console, arg);
  };
} else {
  DEBUG = function() {};
}

util = require('util');

assert = require('assert');

path = require('path');

_ = require('underscore');

_.str = require('underscore.string');

$$ = require('./const').$$;

ArgumentError = require('./error').ArgumentError;

Action = (function() {
  /*Information about how to convert command line strings to Python objects.
  
  Action objects are used by an ArgumentParser to represent the information
  needed to parse a single argument from one or more strings from the
  command line. The keyword arguments to the Action constructor are also
  all attributes of Action instances.
  
  Keyword Arguments:
  
      - option_strings -- A list of command-line option strings which
          should be associated with this action.
  
      - dest -- The name of the attribute to hold the created object(s)
  
      - nargs -- The number of command-line arguments that should be
          consumed. By default, one argument will be consumed and a single
          value will be produced.  Other values include:
              - N (an integer) consumes N arguments (and produces a list)
              - '?' consumes zero or one arguments
              - '*' consumes zero or more arguments (and produces a list)
              - '+' consumes one or more arguments (and produces a list)
          Note that the difference between the default and nargs=1 is that
          with the default, a single value will be produced, while with
          nargs=1, a list containing a single value will be produced.
  
      - constant -- The value to be produced if the option is specified and the
          option uses an action that takes no values.
  
      - defaultValue -- The value to be produced if the option is not specified.
  
      - type -- The type which the command-line arguments should be converted
          to, should be one of 'string', 'int', 'float', 'complex' or a
          callable object that accepts a single string argument. If null,
          'string' is assumed.
  
      - choices -- A container of values that should be allowed. If not null,
          after a command-line argument has been converted to the appropriate
          type, an exception will be raised if it is not a member of this
          collection.
  
      - required -- True if the action must always be specified at the
          command line. This is only meaningful for optional command-line
          arguments.
  
      - help -- The help string describing the argument.
  
      - metavar -- The name to be used for the options argument with the
          help string. If null, the 'dest' value will be used as the name.
  */

  function Action(options) {
    var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    this.option_strings = (_ref = options.option_strings) != null ? _ref : [];
    this.dest = (_ref1 = options.dest) != null ? _ref1 : '';
    this.nargs = (_ref2 = options.nargs) != null ? _ref2 : null;
    this.constant = (_ref3 = options.constant) != null ? _ref3 : null;
    this.defaultValue = (_ref4 = options.defaultValue) != null ? _ref4 : null;
    this.type = (_ref5 = options.type) != null ? _ref5 : null;
    this.choices = (_ref6 = options.choices) != null ? _ref6 : null;
    this.required = (_ref7 = options.required) != null ? _ref7 : false;
    this.help = (_ref8 = options.help) != null ? _ref8 : null;
    this.metavar = (_ref9 = options.metavar) != null ? _ref9 : null;
  }

  Action.prototype.repr = function() {
    var foo, key, value, x;
    foo = function(value) {
      var v, xxx;
      if (_.isString(value)) {
        return "'" + value + "'";
      }
      if (_.isArray(value)) {
        xxx = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            v = value[_i];
            _results.push(foo(v));
          }
          return _results;
        })()).join(', ');
        return "[" + xxx + "]";
      }
      return value;
    };
    x = (function() {
      var _results;
      _results = [];
      for (key in this) {
        if (!__hasProp.call(this, key)) continue;
        value = this[key];
        if (key !== 'container' && (value != null)) {
          _results.push("" + key + ": " + (foo(value)));
        }
      }
      return _results;
    }).call(this);
    x = x.join(', ');
    return "Action {" + x + "}";
  };

  /*
  def _get_kwargs(self):
      names = [
          'option_strings',
          'dest',
          'nargs',
          'constant',
          'defaultValue',
          'type',
          'choices',
          'help',
          'metavar',
      ]
      return [(name, getattr(self, name)) for name in names]
  */


  Action.prototype.__call__ = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    throw new Error(_('.__call__() not defined'));
  };

  Action.prototype.call = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    return this.__call__(parser, namespace, values, option_string = null);
  };

  Action.prototype.getName = function() {
    var _ref, _ref1;
    if (this.option_strings.length > 0) {
      return this.option_strings.join('/');
    } else if ((_ref = this.metavar) != null ? _ref : this.metavar !== $$.SUPPRESS) {
      return this.metavar;
    } else if ((_ref1 = this.dest) != null ? _ref1 : this.dest !== $$.SUPPRESS) {
      return this.dest;
    }
  };

  Action.prototype.isOptional = function() {
    return !this.isPositional();
  };

  Action.prototype.isPositional = function() {
    return this.option_strings.length === 0;
  };

  return Action;

})();

_StoreAction = (function(_super) {

  __extends(_StoreAction, _super);

  function _StoreAction(options) {
    if (options.nargs === 0) {
      throw new Error('nargs for store actions must be > 0; if you ' + 'have nothing to store, actions such as store ' + 'true or store constant may be more appropriate');
    }
    if ((options.constant != null) && options.nargs !== $$.OPTIONAL) {
      throw new Error("nargs must be " + $$.OPTIONAL + " to supply constant");
    }
    _StoreAction.__super__.constructor.call(this, options);
  }

  _StoreAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    return namespace.set(this.dest, values);
  };

  return _StoreAction;

})(Action);

_StoreConstAction = (function(_super) {

  __extends(_StoreConstAction, _super);

  function _StoreConstAction(options) {
    var _ref;
    options.nargs = 0;
    if ((_ref = options.constant) == null) {
      options.constant = options["const"];
    }
    if (options.constant == null) {
      throw new Error('StoreConstAction needs a constant parameter');
    }
    _StoreConstAction.__super__.constructor.call(this, options);
  }

  _StoreConstAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    return namespace.set(this.dest, this.constant);
  };

  return _StoreConstAction;

})(Action);

_StoreTrueAction = (function(_super) {

  __extends(_StoreTrueAction, _super);

  function _StoreTrueAction(options) {
    var _ref;
    options.constant = true;
    if ((_ref = options.defaultValue) == null) {
      options.defaultValue = false;
    }
    _StoreTrueAction.__super__.constructor.call(this, options);
  }

  return _StoreTrueAction;

})(_StoreConstAction);

_StoreFalseAction = (function(_super) {

  __extends(_StoreFalseAction, _super);

  function _StoreFalseAction(options) {
    var _ref;
    options.constant = false;
    if ((_ref = options.defaultValue) == null) {
      options.defaultValue = true;
    }
    _StoreFalseAction.__super__.constructor.call(this, options);
  }

  return _StoreFalseAction;

})(_StoreConstAction);

_AppendAction = (function(_super) {

  __extends(_AppendAction, _super);

  function _AppendAction(options) {
    if (options.nargs === 0) {
      throw new Error('nargs for append actions must be > 0; if arg ' + 'strings are not supplying the value to append, ' + 'the append constant action may be more appropriate');
    }
    if ((options.constant != null) && options.nargs !== $$.OPTIONAL) {
      throw new Error("nargs must be " + $$.OPTIONAL + " to supply constant");
    }
    _AppendAction.__super__.constructor.call(this, options);
  }

  _AppendAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var items;
    if (option_string == null) {
      option_string = null;
    }
    DEBUG(namespace);
    DEBUG(_ensure_value(namespace, this.dest, []));
    items = _.clone(_ensure_value(namespace, this.dest, []));
    items.push(values);
    return namespace.set(this.dest, items);
  };

  return _AppendAction;

})(Action);

_AppendConstAction = (function(_super) {

  __extends(_AppendConstAction, _super);

  function _AppendConstAction(options) {
    var _ref;
    options.nargs = 0;
    if ((_ref = options.constant) == null) {
      options.constant = options["const"];
    }
    if (options.constant != null) {
      _AppendConstAction.__super__.constructor.call(this, options);
    } else {
      throw new Error('constant required for AppendConstAction');
    }
  }

  _AppendConstAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var items;
    if (option_string == null) {
      option_string = null;
    }
    items = _.clone(_ensure_value(namespace, this.dest, []));
    items.push(this.constant);
    return namespace.set(this.dest, items);
  };

  return _AppendConstAction;

})(Action);

_CountAction = (function(_super) {

  __extends(_CountAction, _super);

  function _CountAction(options) {
    options.nargs = 0;
    _CountAction.__super__.constructor.call(this, options);
  }

  _CountAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var new_count;
    if (option_string == null) {
      option_string = null;
    }
    new_count = _ensure_value(namespace, this.dest, 0) + 1;
    return namespace.set(this.dest, new_count);
  };

  return _CountAction;

})(Action);

_HelpAction = (function(_super) {

  __extends(_HelpAction, _super);

  function _HelpAction(options) {
    var _ref, _ref1;
    if ((_ref = options.dest) == null) {
      options.dest = $$.SUPPRESS;
    }
    if ((_ref1 = options.defaultValue) == null) {
      options.defaultValue = $$.SUPPRESS;
    }
    options.nargs = 0;
    _HelpAction.__super__.constructor.call(this, options);
  }

  _HelpAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    if (option_string == null) {
      option_string = null;
    }
    parser.print_help();
    if (parser.debug) {
      console.log('Help pseudo exit');
      return parser.exit();
    } else {
      return parser.exit();
    }
  };

  return _HelpAction;

})(Action);

_VersionAction = (function(_super) {

  __extends(_VersionAction, _super);

  function _VersionAction(options) {
    var _ref, _ref1, _ref2, _ref3;
    if ((_ref = options.version) == null) {
      options.version = null;
    }
    if ((_ref1 = options.dest) == null) {
      options.dest = $$.SUPPRESS;
    }
    if ((_ref2 = options.defaultValue) == null) {
      options.defaultValue = $$.SUPPRESS;
    }
    if ((_ref3 = options.help) == null) {
      options.help = "show program's version number and exit";
    }
    _VersionAction.__super__.constructor.call(this, options);
    this.version = options.version;
  }

  _VersionAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var formatter, version;
    if (option_string == null) {
      option_string = null;
    }
    version = this.version;
    if (version == null) {
      version = parser.version;
    }
    formatter = parser._get_formatter();
    formatter.add_text(version);
    return parser.exit(formatter.format_help());
  };

  return _VersionAction;

})(Action);

_SubParsersAction = (function(_super) {
  var _ChoicesPseudoAction;

  __extends(_SubParsersAction, _super);

  _ChoicesPseudoAction = (function(_super1) {

    __extends(_ChoicesPseudoAction, _super1);

    function _ChoicesPseudoAction(name, aliases, help) {
      var dest, metavar, options;
      metavar = dest = name;
      if (aliases.length > 0) {
        metavar += " (" + (aliases.join(', ')) + ")";
      }
      options = {
        option_strings: [],
        dest: name,
        help: help,
        metavar: metavar
      };
      _ChoicesPseudoAction.__super__.constructor.call(this, options);
    }

    return _ChoicesPseudoAction;

  })(Action);

  function _SubParsersAction(options) {
    var _ref, _ref1,
      _this = this;
    this._getSubactions = function() {
      return _SubParsersAction.prototype._getSubactions.apply(_this, arguments);
    };
    this._get_subactions = function() {
      return _SubParsersAction.prototype._get_subactions.apply(_this, arguments);
    };
    this._prog_prefix = options.prog;
    this._parser_class = (_ref = options.parser_class) != null ? _ref : options.parserClass;
    this._name_parser_map = {};
    this._choices_actions = [];
    options.dest = (_ref1 = options.dest) != null ? _ref1 : $$.SUPPRESS;
    options.nargs = $$.PARSER;
    options.choices = this._name_parser_map;
    _SubParsersAction.__super__.constructor.call(this, options);
    this.debug = options.debug;
  }

  _SubParsersAction.prototype.add_parser = function(name, options) {
    var alias, aliases, choice_action, help, parser, _i, _len, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    if ((_ref = options.prog) == null) {
      options.prog = "" + this._prog_prefix + " " + name;
    }
    if (options.aliases != null) {
      aliases = options.aliases;
      delete options.aliases;
    } else {
      aliases = [];
    }
    if ((_ref1 = options.debug) == null) {
      options.debug = this.debug;
    }
    if (options.help != null) {
      help = options.help;
      delete options.help;
      choice_action = new _ChoicesPseudoAction(name, aliases, help);
      this._choices_actions.push(choice_action);
    }
    parser = new this._parser_class(options);
    this._name_parser_map[name] = parser;
    for (_i = 0, _len = aliases.length; _i < _len; _i++) {
      alias = aliases[_i];
      this._name_parser_map[alias] = parser;
    }
    return parser;
  };

  _SubParsersAction.prototype.addParser = function(name, options) {
    return this.add_parser(name, options);
  };

  _SubParsersAction.prototype._get_subactions = function() {
    return this._choices_actions;
  };

  _SubParsersAction.prototype._getSubactions = function() {
    return this._get_subactions();
  };

  _SubParsersAction.prototype.__call__ = function(parser, namespace, values, option_string) {
    var arg_strings, astring, choices, msg, parser_name, _i, _len, _ref, _ref1, _results;
    if (option_string == null) {
      option_string = null;
    }
    parser_name = values[0];
    arg_strings = values.slice(1);
    if (this.dest !== $$.SUPPRESS) {
      namespace.set(this.dest, parser_name);
    }
    parser = (_ref = this._name_parser_map[parser_name]) != null ? _ref : null;
    if (parser === null) {
      choices = _.keys(this.name_parser.map).join(', ');
      msg = "unknown parser " + parse_name + " (choices: " + choices + ")";
      throw new ArgumentError(this, msg);
    }
    _ref1 = parser.parse_known_args(arg_strings, namespace), namespace = _ref1[0], arg_strings = _ref1[1];
    if (arg_strings.length > 0) {
      if (namespace[$$._UNRECOGNIZED_ARGS_ATTR] == null) {
        namespace[$$._UNRECOGNIZED_ARGS_ATTR] = [];
      }
      _results = [];
      for (_i = 0, _len = arg_strings.length; _i < _len; _i++) {
        astring = arg_strings[_i];
        _results.push(namespace[$$._UNRECOGNIZED_ARGS_ATTR].push(astring));
      }
      return _results;
    }
  };

  return _SubParsersAction;

})(Action);

_ensure_value = function(namespace, name, value) {
  if (getattr(namespace, name, null) === null) {
    setattr(namespace, name, value);
  }
  return getattr(namespace, name);
};

exports.ActionHelp = _HelpAction;

exports.ActionAppend = _AppendAction;

exports.ActionAppendConstant = _AppendConstAction;

exports.ActionCount = _CountAction;

exports.ActionStore = _StoreAction;

exports.ActionStoreConstant = _StoreConstAction;

exports.ActionStoreTrue = _StoreTrueAction;

exports.ActionStoreFalse = _StoreFalseAction;

exports.ActionVersion = _VersionAction;

exports.ActionSubparsers = _SubParsersAction;

getattr = function(obj, key, defaultValue) {
  var _ref;
  return (_ref = obj[key]) != null ? _ref : defaultValue;
};

setattr = function(obj, key, value) {
  return obj[key] = value;
};

hasattr = function(obj, key) {
  return obj[key] != null;
};

Namespace = (function() {

  function Namespace() {}

  return Namespace;

})();

Namespace.prototype.isset = function(key) {
  return this[key] != null;
};

Namespace.prototype.get = function(key, defaultValue) {
  var _ref;
  return (_ref = this[key]) != null ? _ref : defaultValue;
};

Namespace.prototype.set = function(key, value) {
  return this[key] = value;
};

Namespace.prototype.repr = function() {
  return 'Namespace' + util.inspect(this);
};

if (module.parent == null) {
  console.log(action = new Action({
    help: 'testing Action'
  }));
  console.log(action = new _StoreAction({
    dest: 'xxx',
    help: 'testing StoreAction'
  }));
  action.call(null, namespace = new Namespace(), 1);
  console.log(namespace);
  console.log(action = new _StoreConstAction({
    dest: 'xxx',
    help: 'testing StoreConstAction',
    constant: 4
  }));
  action.call(null, namespace = new Namespace());
  console.log(namespace);
  console.log(action = new _StoreTrueAction({
    dest: 'xxx',
    help: 'testing storeTrue'
  }));
  action.call(null, namespace = new Namespace());
  console.log(namespace);
  console.log(action = new _StoreFalseAction({
    dest: 'xxx',
    help: 'testing storeFalse'
  }));
  action.call(null, namespace = new Namespace());
  console.log(namespace);
  console.log(action = new _AppendAction({
    dest: 'xxx',
    help: 'testing AppendAction',
    constant: 'x',
    nargs: '?'
  }));
  namespace = new Namespace();
  namespace.set('xxx', [2, 3]);
  action.call(null, namespace, 1);
  console.log(namespace);
  console.log(action = new _AppendConstAction({
    dest: 'xxx',
    constant: 0,
    help: 'testing AppendConstAction',
    nargs: '?'
  }));
  action.call(null, namespace, 1);
  console.log(namespace);
  console.log(action = new _CountAction({
    dest: 'xxx',
    help: 'testing CountAction',
    nargs: '?'
  }));
  action.call(null, namespace = new Namespace());
  console.log(namespace);
  action.call(null, namespace);
  console.log(namespace);
  parser = {};
  parser.debug = false;
  parser.print_help = function() {
    return console.log("HELP");
  };
  parser.exit = function(msg) {
    if (msg == null) {
      msg = '';
    }
    return console.log("EXIT", msg);
  };
  console.log('parser', parser);
  console.log(action = new _HelpAction({}));
  action.call(parser);
  parser._get_formatter = function() {
    var formatter;
    formatter = {};
    formatter.add_text = function(text) {
      this.text = text;
    };
    formatter.format_help = function() {
      return "help;version " + this.text;
    };
    return formatter;
  };
  console.log(action = new _VersionAction({
    version: '1.2.3'
  }));
  action.call(parser);
}
