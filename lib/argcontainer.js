// Generated by CoffeeScript 1.4.0

/*
# class _ActionsContainer
# not meant to be exported to users
# may need to do action group at the same time
*/


(function() {
  var $$, ActionAppend, ActionAppendConstant, ActionCount, ActionHelp, ActionStore, ActionStoreConstant, ActionStoreFalse, ActionStoreTrue, ActionSubparsers, ActionVersion, DEBUG, action, adir, assert, container, path, util, _, _ActionsContainer, _ArgumentGroup, _MutuallyExclusiveGroup,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (!(module.parent != null)) {
    DEBUG = function() {
      var arg;
      arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      arg.unshift('====> ');
      return console.log.apply(console, arg);
    };
  } else {
    DEBUG = function() {};
  }

  util = require('util');

  assert = require('assert');

  path = require('path');

  _ = require('underscore');

  _.str = require('underscore.string');

  adir = './';

  $$ = require(adir + 'const');

  if (false) {
    ActionHelp = require(adir + 'action/help');
    ActionAppend = require(adir + 'action/append');
    ActionAppendConstant = require(adir + 'action/append/constant');
    ActionCount = require(adir + 'action/count');
    ActionStore = require(adir + 'action/store');
    ActionStoreConstant = require(adir + 'action/store/constant');
    ActionStoreTrue = require(adir + 'action/store/true');
    ActionStoreFalse = require(adir + 'action/store/false');
    ActionVersion = require(adir + 'action/version');
    ActionSubparsers = require(adir + 'action/subparsers');
  } else {
    action = require('./action');
    ActionHelp = action.ActionHelp;
    ActionAppend = action.ActionAppend;
    ActionAppendConstant = action.ActionAppendConstant;
    ActionCount = action.ActionCount;
    ActionStore = action.ActionStore;
    ActionStoreConstant = action.ActionStoreConstant;
    ActionStoreTrue = action.ActionStoreTrue;
    ActionStoreFalse = action.ActionStoreFalse;
    ActionVersion = action.ActionVersion;
    ActionSubparsers = action.ActionSubparsers;
  }

  _ActionsContainer = (function() {

    function _ActionsContainer(options) {
      var _ref;
      if (options == null) {
        options = {};
      }
      this._add_container_actions = __bind(this._add_container_actions, this);

      this.description = options.description;
      this.argument_default = options.argument_default;
      this.prefix_chars = (_ref = options.prefixChars) != null ? _ref : options.prefix_chars;
      this.conflictHandler = options.conflictHandler;
      this._registries = {};
      this.register('action', null, ActionStore);
      this.register('action', 'store', ActionStore);
      this.register('action', 'storeConst', ActionStoreConstant);
      this.register('action', 'store_const', ActionStoreConstant);
      this.register('action', 'storeTrue', ActionStoreTrue);
      this.register('action', 'store_true', ActionStoreTrue);
      this.register('action', 'storeFalse', ActionStoreFalse);
      this.register('action', 'store_false', ActionStoreFalse);
      this.register('action', 'append', ActionAppend);
      this.register('action', 'appendConst', ActionAppendConstant);
      this.register('action', 'append_const', ActionAppendConstant);
      this.register('action', 'count', ActionCount);
      this.register('action', 'help', ActionHelp);
      this.register('action', 'version', ActionVersion);
      this.register('action', 'parsers', ActionSubparsers);
      this._get_handler();
      this._actions = [];
      this._option_string_actions = {};
      this._action_groups = [];
      this._mutually_exclusive_groups = [];
      this._defaults = {};
      this._negative_number_matcher = /^-\d+$|^-\d*\.\d+$/;
      this._hasNegativeNumberOptionals = [];
      this;

    }

    _ActionsContainer.prototype.register = function(registry_name, value, object) {
      var registry;
      if (!_.has(this._registries, registry_name)) {
        this._registries[registry_name] = {};
      }
      registry = this._registries[registry_name];
      return registry[value] = object;
    };

    _ActionsContainer.prototype._registry_get = function(registry_name, value, defaultValue) {
      var _ref;
      if (defaultValue == null) {
        defaultValue = null;
      }
      return (_ref = this._registries[registry_name][value]) != null ? _ref : defaultValue;
    };

    _ActionsContainer.prototype._registryGet = function(arg1, arg2, arg3) {
      return this._registry_get(arg1, arg2, arg3);
    };

    _ActionsContainer.prototype.set_defaults = function(options) {
      var _i, _len, _ref, _results;
      _.extend(this._defaults, options);
      _ref = this._actions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        action = _ref[_i];
        if (action.dest in options) {
          _results.push(action["default"] = options[action.dest]);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    _ActionsContainer.prototype.setDefaults = function(options) {
      return this.set_defaults(options);
    };

    _ActionsContainer.prototype.get_default = function(dest) {
      var _i, _len, _ref, _ref1;
      _ref = this._actions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        action = _ref[_i];
        if (action.dest === dest && action.defaultValue !== null) {
          return action.defaultValue;
        }
      }
      return (_ref1 = this._defaults[dest]) != null ? _ref1 : null;
    };

    _ActionsContainer.prototype.getDefault = function(dest) {
      return this.get_default(dest);
    };

    _ActionsContainer.prototype.add_argument = function() {
      var action_class, args, chars, dest, options, type_func, _i, _ref;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), options = arguments[_i++];
      "add_argument(dest, ..., name=value, ...)\nadd_argument(option_string, option_string, ..., name=value, ...)";

      if (_.isString(options)) {
        args.push(options);
        options = {};
      }
      if (!(options != null)) {
        options = {};
      }
      DEBUG('args, options: ', args, options);
      chars = this.prefix_chars;
      if (args.length === 0 || (args.length === 1 && (_ref = args[0][0], __indexOf.call(chars, _ref) < 0))) {
        if (args.length > 0 && 'dest' in options) {
          throw new Error('dest supplied twice for positional argument');
        }
        options = this._get_positional_options(args, options);
      } else {
        options = this._get_optional_options(args, options);
      }
      DEBUG(options);
      options.optionStrings = options.option_strings;
      if (!('defaultValue' in options)) {
        dest = options['dest'];
        if (dest in this._defaults) {
          options['defaultValue'] = this._defaults[dest];
        } else if (this.argument_default !== null) {
          options['defaultValue'] = this.argument_default;
        } else {
          options['defaultValue'] = null;
        }
      }
      action_class = this._pop_action_class(options);
      if (!_.isFunction(action_class)) {
        throw new Error("unknown action '" + action_class + "'");
      }
      action = new action_class(options);
      type_func = this._registry_get('type', action.type, action.type);
      if (!_.isFunction(type_func)) {
        throw new Error("" + type_func + " is not callable");
      }
      if (this._get_formatter != null) {
        try {
          this._get_formatter()._format_args(action, null);
        } catch (error) {
          throw new Error("length of metavar tuple does not match nargs");
        }
      }
      DEBUG('action', action);
      return this._add_action(action);
    };

    _ActionsContainer.prototype.addArgument = function(args, options) {
      return this.add_argument.apply(this, __slice.call(args).concat([options]));
    };

    _ActionsContainer.prototype.add_argument_group = function(options) {
      var group;
      group = new _ArgumentGroup(this, options);
      this._action_groups.push(group);
      return group;
    };

    _ActionsContainer.prototype.addArgumentGroup = function(options) {
      return this.add_argument_group(options);
    };

    _ActionsContainer.prototype.add_mutually_exclusive_group = function(options) {
      var group;
      if (options == null) {
        options = {};
      }
      group = new _MutuallyExclusiveGroup(this, options);
      this._mutually_exclusive_groups.push(group);
      return group;
    };

    _ActionsContainer.prototype.addMutuallyExclusiveGroup = function(options) {
      return this.add_mutually_exclusive_group(options);
    };

    _ActionsContainer.prototype._add_action = function(action) {
      var option_string, _i, _j, _len, _len1, _ref, _ref1;
      this._check_conflict(action);
      this._actions.push(action);
      action.container = this;
      _ref = action.optionStrings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option_string = _ref[_i];
        this._option_string_actions[option_string] = action;
      }
      _ref1 = action.optionStrings;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        option_string = _ref1[_j];
        if (option_string.match(this._negative_number_matcher)) {
          if (!_.any(this._hasNegativeNumberOptionals)) {
            this._hasNegativeNumberOptionals.push(true);
          }
        }
      }
      return action;
    };

    _ActionsContainer.prototype._remove_action = function(action) {
      var i;
      i = this._actions.indexOf(action);
      if (i >= 0) {
        return delete this._actions[i];
      }
    };

    _ActionsContainer.prototype._add_container_actions = function(container) {
      var actionHash, ctr, group, group_map, msg, mutex_group, required, title_group_map, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;
      title_group_map = {};
      DEBUG(this);
      _ref = this._action_groups;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        group = _ref[_i];
        if (group.title in title_group_map) {
          msg = "cannot merge actions - two groups are named " + group.title;
          throw new Error(msg);
        }
        title_group_map[group.title] = group;
      }
      group_map = {};
      actionHash = function(action) {
        return action.getName();
      };
      _ref1 = container._action_groups;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        group = _ref1[_j];
        if (!(group.title in title_group_map)) {
          title_group_map[group.title] = this.add_argument_group({
            title: group.title,
            description: group.description,
            conflictHandler: group.conflictHandler
          });
        }
        _ref2 = group._group_actions;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          action = _ref2[_k];
          group_map[actionHash(action)] = title_group_map[group.title];
        }
      }
      _ref3 = container._mutually_exclusive_groups;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        group = _ref3[_l];
        mutex_group = this.add_mutually_exclusive_group(required = group.required);
        _ref4 = group._group_actions;
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          action = _ref4[_m];
          group_map[actionHash(action)] = mutex_group;
        }
      }
      _ref5 = container._actions;
      _results = [];
      for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
        action = _ref5[_n];
        ctr = (_ref6 = group_map[action.getName()]) != null ? _ref6 : this;
        _results.push(ctr._add_action(action));
      }
      return _results;
    };

    _ActionsContainer.prototype._get_positional_options = function(dest, options) {
      var msg, result, _ref;
      if ('required' in options) {
        msg = "'required' is an invalid argument for positionals";
        throw new TypeError(msg);
      }
      if (_.isArray(dest)) {
        if (dest.length === 0) {
          dest = null;
        } else {
          dest = dest[0];
        }
      }
      DEBUG('in pos', dest, options);
      /*
              if options.get('nargs') not in [$$.OPTIONAL, $$.ZERO_OR_MORE]
                  options['required'] = True
              if options.get('nargs') == $$.ZERO_OR_MORE and 'defaultValue' not of options
                  options['required'] = True
      */

      if ((_ref = options.nargs) !== $$.OPTIONAL && _ref !== $$.ZERO_OR_MORE) {
        options.required = true;
      } else if (options.nargs === $$.ZERO_OR_MORE && !(options.defaultValue != null)) {
        options.required = true;
      } else {
        options.required = false;
      }
      result = _.clone(options);
      if (dest != null) {
        result['dest'] = dest;
      }
      result['option_strings'] = [];
      return result;
    };

    _ActionsContainer.prototype._get_optional_options = function(args, options) {
      var dest, dest_option_string, long_option_strings, msg, option_string, option_strings, result, _i, _len, _ref, _ref1, _ref2;
      option_strings = [];
      long_option_strings = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        option_string = args[_i];
        if (_ref = !option_string[0], __indexOf.call(this.prefix_chars, _ref) >= 0) {
          msg = "invalid option string " + option_string + ": '                        'must start with a character " + this.prefix_chars;
          throw new Error(msg);
        }
        option_strings.push(option_string);
        if (_ref1 = option_string[0], __indexOf.call(this.prefix_chars, _ref1) >= 0) {
          if (option_string.length > 1) {
            if (_ref2 = option_string[1], __indexOf.call(this.prefix_chars, _ref2) >= 0) {
              long_option_strings.push(option_string);
            }
          }
        }
      }
      if (options['dest'] != null) {
        dest = options['dest'];
        delete options['dest'];
      } else {
        dest = null;
      }
      if (dest === null) {
        if (long_option_strings.length > 0) {
          dest_option_string = long_option_strings[0];
        } else {
          dest_option_string = option_strings[0];
        }
        dest = _.str.lstrip(dest_option_string, this.prefix_chars);
        if (!dest) {
          msg = "dest= is required for options like " + option_string;
          throw new Error(msg);
        }
        dest = dest.replace('-', '_');
      }
      result = _.clone(options);
      result['dest'] = dest;
      result['option_strings'] = option_strings;
      return result;
    };

    _ActionsContainer.prototype._pop_action_class = function(options, defaultValue) {
      if (defaultValue == null) {
        defaultValue = null;
      }
      if (options['action'] != null) {
        action = options['action'];
        delete options['action'];
      } else {
        action = defaultValue;
      }
      return this._registry_get('action', action, action);
    };

    _ActionsContainer.prototype._get_handler = function() {
      var handler_func_name, msg;
      handler_func_name = "_handle_conflict_" + this.conflictHandler;
      try {
        return this[handler_func_name];
      } catch (error) {
        msg = "invalid conflict_resolution value: " + this.conflictHandler;
        throw new Error(msg);
      }
    };

    _ActionsContainer.prototype._check_conflict = function(action) {
      var confl_optional, confl_optionals, conflictHandler, option_string, _i, _len, _ref;
      DEBUG('check', action);
      confl_optionals = [];
      _ref = action.optionStrings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option_string = _ref[_i];
        if (option_string in this._option_string_actions) {
          confl_optional = this._option_string_actions[option_string];
          confl_optionals.push([option_string, confl_optional]);
        }
      }
      if (confl_optionals.length > 0) {
        conflictHandler = this._get_handler();
        return conflictHandler(action, confl_optionals);
      }
    };

    _ActionsContainer.prototype._handle_conflict_error = function(action, conflicting_actions) {
      var conflict_string, message;
      conflict_string = 'TODO';
      message = ": conflicting option string(s): " + conflict_string;
      throw new Error(action.getName() + message);
    };

    /*
        _handle_conflict_resolve: (action, conflicting_actions) ->
    
            # remove all conflicting options
            for [option_string, action] in conflicting_actions
    
                # remove the conflicting option
                #action.optionStrings.remove(option_string)
                i = action.optionStrings.indexOf(option_string)
                if i>=0
                  delete action.optionStrings[i]
                # @_option_string_actions.pop(option_string, null)
                delete @_option_string_actions[option_string]
                
    
                # if the option now has no option string, remove it from the
                # container holding it
                if action.optionStrings.length==0
                    action.container._remove_action(action)
    */


    return _ActionsContainer;

  })();

  exports._ActionsContainer = _ActionsContainer;

  _ArgumentGroup = (function(_super) {

    __extends(_ArgumentGroup, _super);

    function _ArgumentGroup(container, options) {
      var _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      options.prefix_chars = (_ref = options.prefixChars) != null ? _ref : container.prefix_chars;
      options.argument_default = (_ref1 = options.argument_default) != null ? _ref1 : container.argument_default;
      options.conflictHandler = (_ref2 = options.conflictHandler) != null ? _ref2 : container.conflictHandler;
      _ArgumentGroup.__super__.constructor.call(this, options);
      this.title = options.title;
      this._group_actions = [];
      this._registries = container._registries;
      this._actions = container._actions;
      this._option_string_actions = container._option_string_actions;
      this._defaults = container._defaults;
      this._hasNegativeNumberOptionals = container._hasNegativeNumberOptionals;
      this._mutually_exclusive_groups = container._mutually_exclusive_groups;
      this._container = container;
    }

    _ArgumentGroup.prototype._add_action = function(action) {
      action = _ArgumentGroup.__super__._add_action.call(this, action);
      this._group_actions.push(action);
      return action;
    };

    _ArgumentGroup.prototype._remove_action = function(action) {
      _ArgumentGroup.__super__._remove_action.call(this, action);
      return this._group_actions.remove(action);
    };

    return _ArgumentGroup;

  })(_ActionsContainer);

  _MutuallyExclusiveGroup = (function(_super) {

    __extends(_MutuallyExclusiveGroup, _super);

    function _MutuallyExclusiveGroup(container, options) {
      _MutuallyExclusiveGroup.__super__.constructor.call(this, container, options);
      this.required = options.required;
    }

    _MutuallyExclusiveGroup.prototype._add_action = function(action) {
      var msg;
      if (action.required) {
        msg = 'mutually exclusive arguments must be optional';
        raise(new Error(msg));
      }
      action = this._container._add_action(action);
      this._group_actions.push(action);
      return action;
    };

    _MutuallyExclusiveGroup.prototype._remove_action = function(action) {
      this._container._remove_action(action);
      return this._group_actions.remove(action);
    };

    return _MutuallyExclusiveGroup;

  })(_ArgumentGroup);

  if (!(module.parent != null)) {
    container = new _ActionsContainer({
      description: 'a desciption',
      prefixChars: '-',
      argument_default: null,
      conflictHandler: 'error'
    });
    console.log(container);
    container.register('type', null, function(x) {
      return x;
    });
    container.add_argument('-x', '--xxx', {
      help: 'testing'
    });
    container.add_argument('-f', {
      help: 'test short opt'
    });
    container.add_argument({
      dest: 'pos'
    });
    container.add_argument('pos1', {
      nargs: '?'
    });
    container.add_argument('--test');
    console.log(container);
  }

}).call(this);
